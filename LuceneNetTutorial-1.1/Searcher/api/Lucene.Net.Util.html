<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>Lucene.Net.Util</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">Lucene.Net.Util Namespace</h1></div></div><div id="nstext"><p><a href="Lucene.Net.Util~Hierarchy.html">Namespace Hierarchy</a></p><h3 class="dtH3">Classes</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Class</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.ArrayUtil.html">ArrayUtil</a></td><td width="50%"> Methods for manipulating arrays.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.Attribute.html">Attribute</a></td><td width="50%"> Base class for Attributes that can be added to a <a href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a>. <p xmlns="urn:ndoc-schema"></p> Attributes are used to add data in a dynamic, yet type-safe way to a source of usually streamed objects, e. g. a <a href="Lucene.Net.Analysis.TokenStream.html">TokenStream</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a></td><td width="50%"> An AttributeSource contains a list of different <a href="Lucene.Net.Util.Attribute.html">Attribute</a>s, and methods to add and get them. There can only be a single instance of an attribute in the same AttributeSource instance. This is ensured by passing in the actual type of the Attribute (Class&lt;Attribute&gt;) to the <a href="Lucene.Net.Util.AttributeSource.AddAttribute$$1.html">AddAttribute(T)</a>, which then checks if an instance of that type is already present. If yes, it returns the instance, otherwise it creates a new instance and returns it. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.AttributeSource.AttributeFactory.html">AttributeSource.AttributeFactory</a></td><td width="50%"> An AttributeFactory creates instances of <a href="Lucene.Net.Util.Attribute.html">Attribute</a>s.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.AttributeSource.State.html">AttributeSource.State</a></td><td width="50%"> This class holds the state of an AttributeSource.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.AverageGuessMemoryModel.html">AverageGuessMemoryModel</a></td><td width="50%"> An average, best guess, MemoryModel that should work okay on most systems. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.BitUtil.html">BitUtil</a></td><td width="50%">A variety of high efficiencly bit twiddling routines. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.BitVector.html">BitVector</a></td><td width="50%">Optimized implementation of a vector of bits. This is more-or-less like java.util.BitSet, but also includes the following: <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li>a count() method, which efficiently computes the number of one bits;</li><li>optimized read from and write to disk;</li><li>inlinable get() method;</li><li>store and load, as bit set or d-gaps, depending on sparseness;</li></ul></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.CloseableThreadLocal$1.html">CloseableThreadLocal(T)</a></td><td width="50%">Java's builtin ThreadLocal has a serious flaw: it can take an arbitrarily long amount of time to dereference the things you had stored in it, even once the ThreadLocal instance itself is no longer referenced. This is because there is single, master map stored for each thread, which all ThreadLocals share, and that master map only periodically purges "stale" entries. While not technically a memory leak, because eventually the memory will be reclaimed, it can take a long time and you can easily hit OutOfMemoryError because from the GC's standpoint the stale entries are not reclaimaible. This class works around that, by only enrolling WeakReference values into the ThreadLocal, and separately holding a hard reference to each stored value. When you call <a href="Lucene.Net.Util.CloseableThreadLocal$1.Close.html">Close</a>, these hard references are cleared and then GC is freely able to reclaim space by objects stored in it. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.Constants.html">Constants</a></td><td width="50%"> Some useful constants.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.DocIdBitSet.html">DocIdBitSet</a></td><td width="50%">Simple DocIdSet and DocIdSetIterator backed by a BitSet </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.FieldCacheSanityChecker.html">FieldCacheSanityChecker</a></td><td width="50%"> Provides methods for sanity checking that entries in the FieldCache are not wasteful or inconsistent. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p> Lucene 2.9 Introduced numerous enhancements into how the FieldCache is used by the low levels of Lucene searching (for Sorting and ValueSourceQueries) to improve both the speed for Sorting, as well as reopening of IndexReaders. But these changes have shifted the usage of FieldCache from "top level" IndexReaders (frequently a MultiReader or DirectoryReader) down to the leaf level SegmentReaders. As a result, existing applications that directly access the FieldCache may find RAM usage increase significantly when upgrading to 2.9 or Later. This class provides an API for these applications (or their Unit tests) to check at run time if the FieldCache contains "insane" usages of the FieldCache. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">EXPERIMENTAL API:</b> This API is considered extremely advanced and experimental. It may be removed or altered w/o warning in future releases of Lucene. <p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.FieldCacheSanityChecker.Insanity.html">FieldCacheSanityChecker.Insanity</a></td><td width="50%"> Simple container for a collection of related CacheEntry objects that in conjunction with eachother represent some "insane" usage of the FieldCache. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.html">FieldCacheSanityChecker.InsanityType</a></td><td width="50%"> An Enumaration of the differnet types of "insane" behavior that may be detected in a FieldCache. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.IdentityDictionary$2.html">IdentityDictionary(TKey,TValue)</a></td><td width="50%"> A class that mimics Java's IdentityHashMap in that it determines object equality solely on ReferenceEquals rather than (possibly overloaded) object.Equals(). NOTE: Java's documentation on IdentityHashMap says that it also uses ReferenceEquals on it's Values as well. This class does not follow this behavior </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.IndexableBinaryStringTools.html">IndexableBinaryStringTools</a></td><td width="50%"> Provides support for converting byte sequences to Strings and back again. The resulting Strings preserve the original byte sequences' sort order. The Strings are constructed using a Base 8000h encoding of the original binary data - each char of an encoded String represents a 15-bit chunk from the byte sequence. Base 8000h was chosen because it allows for all lower 15 bits of char to be used without restriction; the surrogate range [U+D8000-U+DFFF] does not represent valid chars, and would require complicated handling to avoid them and allow use of char's high bit. Although unset bits are used as padding in the final char, the original byte sequence could contain trailing bytes with no set bits (null bytes): padding is indistinguishable from valid information. To overcome this problem, a char is appended, indicating the number of encoded bytes in the final content char. This class's operations are defined over CharBuffers and ByteBuffers, to allow for wrapped arrays to be reused, reducing memory allocation costs for repeated operations. Note that this class calls array() and arrayOffset() on the CharBuffers and ByteBuffers it uses, so only wrapped arrays may be used. This class interprets the arrayOffset() and limit() values returned by its input buffers as beginning and end+1 positions on the wrapped array, resprectively; similarly, on the output buffer, arrayOffset() is the first position written to, and limit() is set to one past the final output array position. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.MapOfSets$2.html">MapOfSets(TKey,TValue)</a></td><td width="50%"> Helper class for keeping Listss of Objects associated with keys. <b xmlns="urn:ndoc-schema">WARNING: THIS CLASS IS NOT THREAD SAFE</b></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.MemoryModel.html">MemoryModel</a></td><td width="50%"> Returns primitive memory sizes for estimating RAM usage. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.NumericUtils.html">NumericUtils</a></td><td width="50%"> This is a helper class to generate prefix-encoded representations for numerical values and supplies converters to represent float/double values as sortable integers/longs. <p xmlns="urn:ndoc-schema"></p>To quickly execute range queries in Apache Lucene, a range is divided recursively into multiple intervals for searching: The center of the range is searched only with the lowest possible precision in the trie, while the boundaries are matched more exactly. This reduces the number of terms dramatically. <p xmlns="urn:ndoc-schema"></p>This class generates terms to achive this: First the numerical integer values need to be converted to strings. For that integer values (32 bit or 64 bit) are made unsigned and the bits are converted to ASCII chars with each 7 bit. The resulting string is sortable like the original integer value. Each value is also prefixed (in the first char) by the <code xmlns:ndoc="urn:ndoc-schema">shift</code> value (number of bits removed) used during encoding. <p xmlns="urn:ndoc-schema"></p>To also index floating point numbers, this class supplies two methods to convert them to integer values by changing their bit layout: <a href="Lucene.Net.Util.NumericUtils.DoubleToSortableLong.html">DoubleToSortableLong</a>, <a href="Lucene.Net.Util.NumericUtils.FloatToSortableInt.html">FloatToSortableInt</a>. You will have no precision loss by converting floating point numbers to integers and back (only that the integer form is not usable). Other data types like dates can easily converted to longs or ints (e.g. date to long: <a href="http://msdn.microsoft.com/en-us/library/System.DateTime(VS.100).aspx">DateTime</a>). <p xmlns="urn:ndoc-schema"></p>For easy usage, the trie algorithm is implemented for indexing inside <a href="Lucene.Net.Analysis.NumericTokenStream.html">NumericTokenStream</a> that can index <code xmlns:ndoc="urn:ndoc-schema">int</code>, <code xmlns:ndoc="urn:ndoc-schema">long</code>, <code xmlns:ndoc="urn:ndoc-schema">float</code>, and <code xmlns:ndoc="urn:ndoc-schema">double</code>. For querying, <a href="Lucene.Net.Search.NumericRangeQuery$1.html">NumericRangeQuery(T)</a> and <a href="Lucene.Net.Search.NumericRangeFilter$1.html">NumericRangeFilter(T)</a> implement the query part for the same data types. <p xmlns="urn:ndoc-schema"></p>This class can also be used, to generate lexicographically sortable (according <a href="http://msdn.microsoft.com/en-us/library/System.String.CompareTo(System.String)(VS.100).aspx">CompareTo</a>) representations of numeric data types for other usages (e.g. sorting). <p xmlns="urn:ndoc-schema"></p><font color="red" xmlns="urn:ndoc-schema"><b>NOTE:</b> This API is experimental and might change in incompatible ways in the next release.</font></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.NumericUtils.IntRangeBuilder.html">NumericUtils.IntRangeBuilder</a></td><td width="50%"> Expert: Callback for <a href="Lucene.Net.Util.NumericUtils.SplitIntRange.html">SplitIntRange</a>. You need to overwrite only one of the methods. <p xmlns="urn:ndoc-schema"></p><font color="red" xmlns="urn:ndoc-schema"><b>NOTE:</b> This is a very low-level interface, the method signatures may change in later versions.</font></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.NumericUtils.LongRangeBuilder.html">NumericUtils.LongRangeBuilder</a></td><td width="50%"> Expert: Callback for <a href="Lucene.Net.Util.NumericUtils.SplitLongRange.html">SplitLongRange</a>. You need to overwrite only one of the methods. <p xmlns="urn:ndoc-schema"></p><font color="red" xmlns="urn:ndoc-schema"><b>NOTE:</b> This is a very low-level interface, the method signatures may change in later versions.</font></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a></td><td width="50%">An "open" BitSet implementation that allows direct access to the array of words storing the bits. <p xmlns="urn:ndoc-schema"></p> Unlike java.util.bitset, the fact that bits are packed into an array of longs is part of the interface. This allows efficient implementation of other algorithms by someone other than the author. It also allows one to efficiently implement alternate serialization or interchange formats. <p xmlns="urn:ndoc-schema"></p><code xmlns:ndoc="urn:ndoc-schema">OpenBitSet</code> is faster than <code xmlns:ndoc="urn:ndoc-schema">java.util.BitSet</code> in most operations and *much* faster at calculating cardinality of sets and results of set operations. It can also handle sets of larger cardinality (up to 64 * 2**32-1) <p xmlns="urn:ndoc-schema"></p> The goals of <code xmlns:ndoc="urn:ndoc-schema">OpenBitSet</code> are the fastest implementation possible, and maximum code reuse. Extra safety and encapsulation may always be built on top, but if that's built in, the cost can never be removed (and hence people re-implement their own version in order to get better performance). If you want a "safe", totally encapsulated (and slower and limited) BitSet class, use <code xmlns:ndoc="urn:ndoc-schema">java.util.BitSet</code>. <p xmlns="urn:ndoc-schema"></p><h3 xmlns="urn:ndoc-schema">Performance Results</h3> Test system: Pentium 4, Sun Java 1.5_06 -server -Xbatch -Xmx64M <br xmlns:ndoc="urn:ndoc-schema" />BitSet size = 1,000,000 <br xmlns:ndoc="urn:ndoc-schema" />Results are java.util.BitSet time divided by OpenBitSet time. <table border="1" xmlns="urn:ndoc-schema"><tr><th></th><th>cardinality</th><th>intersect_count</th><th>union</th><th>nextSetBit</th><th>get</th><th>iterator</th></tr><tr><th>50% full</th><td>3.36</td><td>3.96</td><td>1.44</td><td>1.46</td><td>1.99</td><td>1.58</td></tr><tr><th>1% full</th><td>3.31</td><td>3.90</td><td> </td><td>1.04</td><td> </td><td>0.99</td></tr></table><br xmlns:ndoc="urn:ndoc-schema" /> Test system: AMD Opteron, 64 bit linux, Sun Java 1.5_06 -server -Xbatch -Xmx64M <br xmlns:ndoc="urn:ndoc-schema" />BitSet size = 1,000,000 <br xmlns:ndoc="urn:ndoc-schema" />Results are java.util.BitSet time divided by OpenBitSet time. <table border="1" xmlns="urn:ndoc-schema"><tr><th></th><th>cardinality</th><th>intersect_count</th><th>union</th><th>nextSetBit</th><th>get</th><th>iterator</th></tr><tr><th>50% full</th><td>2.50</td><td>3.50</td><td>1.00</td><td>1.03</td><td>1.12</td><td>1.25</td></tr><tr><th>1% full</th><td>2.51</td><td>3.49</td><td> </td><td>1.00</td><td> </td><td>1.02</td></tr></table></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.OpenBitSetDISI.html">OpenBitSetDISI</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.OpenBitSetIterator.html">OpenBitSetIterator</a></td><td width="50%">An iterator to iterate over set bits in an OpenBitSet. This is faster than nextSetBit() for iterating over the complete set of bits, especially when the density of the bits set is high. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.PriorityQueue$1.html">PriorityQueue(T)</a></td><td width="50%">A PriorityQueue maintains a partial ordering of its elements such that the least element can always be found in constant time. Put()'s and pop()'s require log(size) time. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: This class pre-allocates a full array of length <code xmlns:ndoc="urn:ndoc-schema">maxSize+1</code>, in <a href="Lucene.Net.Util.PriorityQueue$1.Initialize.html">Initialize</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.RamUsageEstimator.html">RamUsageEstimator</a></td><td width="50%"> Estimates the size of a given Object using a given MemoryModel for primitive size information. Resource Usage: Internally uses a Map to temporally hold a reference to every object seen. If checkIntered, all Strings checked will be interned, but those that were not already interned will be released for GC when the estimate is complete. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.ReaderUtil.html">ReaderUtil</a></td><td width="50%"> Common util methods for dealing with <a href="Lucene.Net.Index.IndexReader.html">IndexReader</a>s. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.ScorerDocQueue.html">ScorerDocQueue</a></td><td width="50%">A ScorerDocQueue maintains a partial ordering of its Scorers such that the least Scorer can always be found in constant time. Put()'s and pop()'s require log(size) time. The ordering is by Scorer.doc(). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.SimpleStringInterner.html">SimpleStringInterner</a></td><td width="50%"> Simple lockless and memory barrier free String intern cache that is guaranteed to return the same String instance as String.intern() does. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.SmallFloat.html">SmallFloat</a></td><td width="50%">Floating point numbers smaller than 32 bits. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.SortedVIntList.html">SortedVIntList</a></td><td width="50%"> Stores and iterate on sorted integers in compressed form in RAM. <br xmlns:ndoc="urn:ndoc-schema" /> The code for compressing the differences between ascending integers was borrowed from <a href="Lucene.Net.Store.IndexInput.html">IndexInput</a> and <a href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>.<p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> this class assumes the stored integers are doc Ids (hence why it extends <a href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a>). Therefore its <a href="Lucene.Net.Util.SortedVIntList.Iterator.html">Iterator</a> assumes <a href="Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS.html">NO_MORE_DOCS</a> can be used as sentinel. If you intent to use this value, then make sure it's not used during search flow. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.SorterTemplate.html">SorterTemplate</a></td><td width="50%"> Borrowed from Cglib. Allows custom swap so that two arrays can be sorted at the same time. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.StringHelper.html">StringHelper</a></td><td width="50%"> Methods for manipulating strings.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.StringInterner.html">StringInterner</a></td><td width="50%"> Subclasses of StringInterner are required to return the same single String object for all equal strings. Depending on the implementation, this may not be the same object returned as String.intern(). This StringInterner base class simply delegates to String.intern(). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.ToStringUtils.html">ToStringUtils</a></td><td width="50%"> Helper methods to ease implementing <a href="http://msdn.microsoft.com/en-us/library/System.Object.ToString(VS.100).aspx">ToString</a>.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.UnicodeUtil.html">UnicodeUtil</a></td><td width="50%"> Class to encode java's UTF16 char[] into UTF8 byte[] without always allocating a new byte[] as String.getBytes("UTF-8") does. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: This API is a new and experimental and may suddenly change. <p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.UnicodeUtil.UTF16Result.html">UnicodeUtil.UTF16Result</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.UnicodeUtil.UTF8Result.html">UnicodeUtil.UTF8Result</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.VersionEnumExtensions.html">VersionEnumExtensions</a></td><td width="50%"> </td></tr></table></div><h3 class="dtH3">Interfaces</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Interface</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.IAttribute.html">IAttribute</a></td><td width="50%"> Base interface for attributes.</td></tr></table></div><h3 class="dtH3">Enumerations</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Enumeration</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Util.Version.html">Version</a></td><td width="50%"> Use by certain classes to match version compatibility across releases of Lucene. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: When changing the version parameter that you supply to components in Lucene, do not simply change the version at search-time, but instead also adjust your indexing code to match, and re-index. </td></tr></table></div></div></body></html>