<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>NumericRangeQuery(T) Class</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">NumericRangeQuery(T) Class</h1></div></div><div id="nstext"><p xmlns="urn:ndoc-schema"></p>A <a href="Lucene.Net.Search.Query.html">Query</a> that matches numeric values within a specified range. To use this, you must first index the numeric values using <a href="Lucene.Net.Documents.NumericField.html">NumericField</a> (expert: <a href="Lucene.Net.Analysis.NumericTokenStream.html">NumericTokenStream</a> ). If your terms are instead textual, you should use <a href="Lucene.Net.Search.TermRangeQuery.html">TermRangeQuery</a>. <a href="Lucene.Net.Search.NumericRangeFilter$1.html">NumericRangeFilter(T)</a> is the filter equivalent of this query.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>You create a new NumericRangeQuery with the static factory methods, eg: <pre class="code">Query q = NumericRangeQuery.newFloatRange("weight",
new Float(0.3f), new Float(0.10f),
true, true);
</pre> matches all documents whose float valued "weight" field ranges from 0.3 to 0.10, inclusive. <p xmlns="urn:ndoc-schema"></p>The performance of NumericRangeQuery is much better than the corresponding <b>TermRangeQuery</b> because the number of terms that must be searched is usually far fewer, thanks to trie indexing, described below.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>You can optionally specify a <a href="#precisionStepDesc" xmlns="urn:ndoc-schema"><code xmlns="">precisionStep</code></a> when creating this query. This is necessary if you've changed this configuration from its default (4) during indexing. Lower values consume more disk space but speed up searching. Suitable values are between <b xmlns="urn:ndoc-schema">1</b> and <b xmlns="urn:ndoc-schema">8</b>. A good starting point to test is <b xmlns="urn:ndoc-schema">4</b>, which is the default value for all <code>Numeric*</code> classes. See <a href="#precisionStepDesc" xmlns="urn:ndoc-schema">below</a> for details. <p xmlns="urn:ndoc-schema"></p>This query defaults to <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT.html">CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</a> for 32 bit (int/float) ranges with precisionStep &lt;8 and 64 bit (long/double) ranges with precisionStep &lt;6. Otherwise it uses <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE.html">CONSTANT_SCORE_FILTER_REWRITE</a> as the number of terms is likely to be high. With precision steps of &lt;4, this query can be run with one of the BooleanQuery rewrite methods without changing BooleanQuery's default max clause count. <p xmlns="urn:ndoc-schema"></p><font color="red" xmlns="urn:ndoc-schema"><b>NOTE:</b> This API is experimental and might change in incompatible ways in the next release.</font><br /><h3 xmlns="urn:ndoc-schema">How it works</h3><p xmlns="urn:ndoc-schema"></p>See the publication about <a target="_blank" href="http://www.panfmp.org" xmlns="urn:ndoc-schema">panFMP</a>, where this algorithm was described (referred to as <code>TrieRangeQuery</code>): <blockquote xmlns="urn:ndoc-schema"><strong>Schindler, U, Diepenbroek, M</strong>, 2008. <em>Generic XML-based Framework for Metadata Portals.</em> Computers &amp; Geosciences 34 (12), 1947-1955. <a href="http://dx.doi.org/10.1016/j.cageo.2008.02.023" target="_blank">doi:10.1016/j.cageo.2008.02.023</a></blockquote><p xmlns="urn:ndoc-schema"></p><em xmlns="urn:ndoc-schema">A quote from this paper:</em> Because Apache Lucene is a full-text search engine and not a conventional database, it cannot handle numerical ranges (e.g., field value is inside user defined bounds, even dates are numerical values). We have developed an extension to Apache Lucene that stores the numerical values in a special string-encoded format with variable precision (all numerical values like doubles, longs, floats, and ints are converted to lexicographic sortable string representations and stored with different precisions (for a more detailed description of how the values are stored, see <a href="Lucene.Net.Util.NumericUtils.html">NumericUtils</a>). A range is then divided recursively into multiple intervals for searching: The center of the range is searched only with the lowest possible precision in the <em xmlns="urn:ndoc-schema">trie</em>, while the boundaries are matched more exactly. This reduces the number of terms dramatically.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>For the variant that stores long values in 8 different precisions (each reduced by 8 bits) that uses a lowest precision of 1 byte, the index contains only a maximum of 256 distinct values in the lowest precision. Overall, a range could consist of a theoretical maximum of <code>7*255*2 + 255 = 3825</code> distinct terms (when there is a term for every distinct value of an 8-byte-number in the index and the range covers almost all of them; a maximum of 255 distinct values is used because it would always be possible to reduce the full 256 values to one term with degraded precision). In practice, we have seen up to 300 terms in most cases (index with 500,000 metadata records and a uniform value distribution).<p xmlns="urn:ndoc-schema"></p><a name="precisionStepDesc" xmlns="urn:ndoc-schema"></a><h3 xmlns="urn:ndoc-schema">Precision Step</h3><p xmlns="urn:ndoc-schema"></p>You can choose any <code>precisionStep</code> when encoding values. Lower step values mean more precisions and so more terms in index (and index gets larger). On the other hand, the maximum number of terms to match reduces, which optimized query speed. The formula to calculate the maximum term count is: <pre class="code">n = [ (bitsPerValue/precisionStep - 1) * (2^precisionStep - 1 ) * 2 ] + (2^precisionStep - 1 )
</pre><p xmlns="urn:ndoc-schema"></p><em xmlns="urn:ndoc-schema">(this formula is only correct, when <code xmlns="">bitsPerValue/precisionStep</code> is an integer; in other cases, the value must be rounded up and the last summand must contain the modulo of the division as precision step)</em>. For longs stored using a precision step of 4, <code>n = 15*15*2 + 15 = 465</code>, and for a precision step of 2, <code>n = 31*3*2 + 3 = 189</code>. But the faster search speed is reduced by more seeking in the term enum of the index. Because of this, the ideal <code>precisionStep</code> value can only be found out by testing. <b xmlns="urn:ndoc-schema">Important:</b> You can index with a lower precision step value and test search speed using a multiple of the original step value.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Good values for <code>precisionStep</code> are depending on usage and data type: <ul type="disc"><li>The default for all data types is <b xmlns="urn:ndoc-schema">4</b>, which is used, when no <code>precisionStep</code> is given.</li><li>Ideal value in most cases for <em xmlns="urn:ndoc-schema">64 bit</em> data types <em xmlns="urn:ndoc-schema">(long, double)</em> is <b xmlns="urn:ndoc-schema">6</b> or <b xmlns="urn:ndoc-schema">8</b>.</li><li>Ideal value in most cases for <em xmlns="urn:ndoc-schema">32 bit</em> data types <em xmlns="urn:ndoc-schema">(int, float)</em> is <b xmlns="urn:ndoc-schema">4</b>.</li><li>Steps <b xmlns="urn:ndoc-schema">&gt;64</b> for <em xmlns="urn:ndoc-schema">long/double</em> and <b xmlns="urn:ndoc-schema">&gt;32</b> for <em xmlns="urn:ndoc-schema">int/float</em> produces one token per value in the index and querying is as slow as a conventional <b>TermRangeQuery</b>. But it can be used to produce fields, that are solely used for sorting (in this case simply use <a href="http://msdn.microsoft.com/en-us/library/System.Int32.MaxValue(VS.100).aspx">MaxValue</a> as <code>precisionStep</code>). Using <b>NumericFields</b> for sorting is ideal, because building the field cache is much faster than with text-only numbers. Sorting is also possible with range query optimized fields using one of the above <code>precisionSteps</code>.</li></ul><p xmlns="urn:ndoc-schema"></p>Comparisons of the different types of RangeQueries on an index with about 500,000 docs showed that <b>TermRangeQuery</b> in boolean rewrite mode (with raised <a href="Lucene.Net.Search.BooleanQuery.html">BooleanQuery</a> clause count) took about 30-40 secs to complete, <b>TermRangeQuery</b> in constant score filter rewrite mode took 5 secs and executing this class took &lt;100ms to complete (on an Opteron64 machine, Java 1.5, 8 bit precision step). This query type was developed for a geographic portal, where the performance for e.g. bounding boxes or exact date/time stamps is important.<p xmlns="urn:ndoc-schema"></p><p>
                For a list of all members of this type, see <a href="Lucene.Net.Search.NumericRangeQuery$1~Members.html">NumericRangeQuery(T) Members
                </a>.
              </p><p><a href="http://msdn.microsoft.com/en-us/library/System.Object(VS.100).aspx">System.Object</a><br />   <a href="Lucene.Net.Search.Query.html">Query</a><br />      <a href="Lucene.Net.Search.MultiTermQuery.html">MultiTermQuery</a><br />         <b>NumericRangeQuery(T)</b></p><div class="syntax"><div class="attribute">[Serializable]</div><div>public sealed class NumericRangeQuery&lt;T&gt;<b> : <a href="Lucene.Net.Search.MultiTermQuery.html">MultiTermQuery</a></b><br />where T : struct, IComparable</div></div><H4 class="dtH4">Thread Safety</H4><P>
					Public static (<b>Shared</b> in Visual Basic) members of this type are
					safe for multithreaded operations. Instance members are <b>not</b> guaranteed to be
					thread-safe.
				</P><h4 class="dtH4">Requirements</h4><p><b>Namespace: </b><a href="Lucene.Net.Search.html">Lucene.Net.Search</a></p><p><b>Assembly: </b>Lucene.Net (in Lucene.Net.dll)
          </p><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Search.NumericRangeQuery$1~Members.html">NumericRangeQuery(T) Members</a> | <a href="Lucene.Net.Search.html">Lucene.Net.Search Namespace</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>