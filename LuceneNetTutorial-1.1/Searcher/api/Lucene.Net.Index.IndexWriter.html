<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>IndexWriter Class</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">IndexWriter Class</h1></div></div><div id="nstext">An <code>IndexWriter</code> creates and maintains an index. <p xmlns="urn:ndoc-schema"></p>The <code>create</code> argument to the <a href="Lucene.Net.Index.IndexWriter.~ctor1.html">constructor</a> determines whether a new index is created, or whether an existing index is opened. Note that you can open an index with <code>create=true</code> even while readers are using the index. The old readers will continue to search the "point in time" snapshot they had opened, and won't see the newly created index until they re-open. There are also <a href="Lucene.Net.Index.IndexWriter.~ctor2.html">constructors</a> with no <code>create</code> argument which will create a new index if there is not already an index at the provided path and otherwise open the existing index.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>In either case, documents are added with <a href="Lucene.Net.Index.IndexWriter.AddDocument1.html">AddDocument</a> and removed with <a href="Lucene.Net.Index.IndexWriter.DeleteDocuments1.html">DeleteDocuments</a> or <a href="Lucene.Net.Index.IndexWriter.DeleteDocuments3.html">DeleteDocuments</a>. A document can be updated with <a href="Lucene.Net.Index.IndexWriter.UpdateDocument1.html">UpdateDocument</a> (which just deletes and then adds the entire document). When finished adding, deleting and updating documents, <a href="Lucene.Net.Index.IndexWriter.Close1.html">Close</a> should be called.<p xmlns="urn:ndoc-schema"></p><a name="flush" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p>These changes are buffered in memory and periodically flushed to the <a href="Lucene.Net.Index.IndexWriter.Directory.html">Directory</a> (during the above method calls). A flush is triggered when there are enough buffered deletes (see <a href="Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms.html">SetMaxBufferedDeleteTerms</a>) or enough added documents since the last flush, whichever is sooner. For the added documents, flushing is triggered either by RAM usage of the documents (see <a href="Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB.html">SetRAMBufferSizeMB</a>) or the number of added documents. The default is to flush when RAM usage hits 16 MB. For best indexing speed you should flush by RAM usage with a large RAM buffer. Note that flushing just moves the internal buffered state in IndexWriter into the index, but these changes are not visible to IndexReader until either <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a> or <b>Close</b> is called. A flush may also trigger one or more segment merges which by default run with a background thread so as not to block the addDocument calls (see <a href="#mergePolicy" xmlns="urn:ndoc-schema">below</a> for changing the <a href="Lucene.Net.Index.IndexWriter.MergeScheduler.html">MergeScheduler</a>). <p xmlns="urn:ndoc-schema"></p> If an index will not have more documents added for a while and optimal search performance is desired, then either the full <a href="Lucene.Net.Index.IndexWriter.Optimize1.html">Optimize</a> method or partial <a href="Lucene.Net.Index.IndexWriter.Optimize2.html">Optimize</a> method should be called before the index is closed. <p xmlns="urn:ndoc-schema"></p> Opening an <code>IndexWriter</code> creates a lock file for the directory in use. Trying to open another <code>IndexWriter</code> on the same directory will lead to a <a href="Lucene.Net.Store.LockObtainFailedException.html">LockObtainFailedException</a>. The <b>LockObtainFailedException</b> is also thrown if an IndexReader on the same directory is used to delete documents from the index.<p xmlns="urn:ndoc-schema"></p><a name="deletionPolicy" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p>Expert: <code>IndexWriter</code> allows an optional <a href="Lucene.Net.Index.IndexDeletionPolicy.html">IndexDeletionPolicy</a> implementation to be specified. You can use this to control when prior commits are deleted from the index. The default policy is <a href="Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.html">KeepOnlyLastCommitDeletionPolicy</a> which removes all prior commits as soon as a new commit is done (this matches behavior before 2.2). Creating your own policy can allow you to explicitly keep previous "point in time" commits alive in the index for some time, to allow readers to refresh to the new commit without having the old commit deleted out from under them. This is necessary on filesystems like NFS that do not support "delete on last close" semantics, which Lucene's "point in time" search normally relies on. <p xmlns="urn:ndoc-schema"></p><a name="mergePolicy" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p>Expert: <code>IndexWriter</code> allows you to separately change the <a href="Lucene.Net.Index.IndexWriter.MergePolicy.html">MergePolicy</a> and the <a href="Lucene.Net.Index.IndexWriter.MergeScheduler.html">MergeScheduler</a>. The <b>MergePolicy</b> is invoked whenever there are changes to the segments in the index. Its role is to select which merges to do, if any, and return a <a href="Lucene.Net.Index.MergePolicy.MergeSpecification.html">MergePolicy.MergeSpecification</a> describing the merges. It also selects merges to do for optimize(). (The default is <a href="Lucene.Net.Index.LogByteSizeMergePolicy.html">LogByteSizeMergePolicy</a>. Then, the <b>MergeScheduler</b> is invoked with the requested merges and it decides when and how to run the merges. The default is <a href="Lucene.Net.Index.ConcurrentMergeScheduler.html">ConcurrentMergeScheduler</a>. <p xmlns="urn:ndoc-schema"></p><a name="OOME" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: if you hit an OutOfMemoryError then IndexWriter will quietly record this fact and block all future segment commits. This is a defensive measure in case any internal state (buffered documents and deletions) were corrupted. Any subsequent calls to <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a> will throw an IllegalStateException. The only course of action is to call <a href="Lucene.Net.Index.IndexWriter.Close1.html">Close</a>, which internally will call <a href="Lucene.Net.Index.IndexWriter.Rollback.html">Rollback</a> , to undo any changes to the index since the last commit. You can also just call <b>Rollback</b> directly.<p xmlns="urn:ndoc-schema"></p><a name="thread-safety" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: <b>IndexWriter</b> instances are completely thread safe, meaning multiple threads can call any of its methods, concurrently. If your application requires external synchronization, you should <b xmlns="urn:ndoc-schema">not</b> synchronize on the <code>IndexWriter</code> instance as this may cause deadlock; use your own (non-Lucene) objects instead. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> if you call <code>Thread.Interrupt()</code> on a thread that's within IndexWriter, IndexWriter will try to catch this (eg, if it's in a Wait() or Thread.Sleep()), and will then throw the unchecked exception <a href="http://msdn.microsoft.com/en-us/library/System.Threading.ThreadInterruptedException(VS.100).aspx">ThreadInterruptedException</a> and <b xmlns="urn:ndoc-schema">clear</b> the interrupt status on the thread<p xmlns="urn:ndoc-schema"></p><p>
                For a list of all members of this type, see <a href="Lucene.Net.Index.IndexWriter~Members.html">IndexWriter Members
                </a>.
              </p><p><a href="http://msdn.microsoft.com/en-us/library/System.Object(VS.100).aspx">System.Object</a><br />   <b>IndexWriter</b></p><div class="syntax"><div>public class IndexWriter<b> : <a href="">IDisposable</a></b></div></div><H4 class="dtH4">Thread Safety</H4><P>
					Public static (<b>Shared</b> in Visual Basic) members of this type are
					safe for multithreaded operations. Instance members are <b>not</b> guaranteed to be
					thread-safe.
				</P><h4 class="dtH4">Requirements</h4><p><b>Namespace: </b><a href="Lucene.Net.Index.html">Lucene.Net.Index</a></p><p><b>Assembly: </b>Lucene.Net (in Lucene.Net.dll)
          </p><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Index.IndexWriter~Members.html">IndexWriter Members</a> | <a href="Lucene.Net.Index.html">Lucene.Net.Index Namespace</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>