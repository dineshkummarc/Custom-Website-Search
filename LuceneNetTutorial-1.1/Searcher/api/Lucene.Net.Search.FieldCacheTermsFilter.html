<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>FieldCacheTermsFilter Class</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">FieldCacheTermsFilter Class</h1></div></div><div id="nstext"> A <a href="Lucene.Net.Search.Filter.html">Filter</a> that only accepts documents whose single term value in the specified field is contained in the provided set of allowed terms. <p xmlns="urn:ndoc-schema"></p> This is the same functionality as TermsFilter (from contrib/queries), except this filter requires that the field contains only a single term for all documents. Because of drastically different implementations, they also have different performance characteristics, as described below. <p xmlns="urn:ndoc-schema"></p> The first invocation of this filter on a given field will be slower, since a <a href="Lucene.Net.Search.StringIndex.html">StringIndex</a> must be created. Subsequent invocations using the same field will re-use this cache. However, as with all functionality based on <a href="Lucene.Net.Search.FieldCacheTermsFilter.FieldCache.html">FieldCache</a>, persistent RAM is consumed to hold the cache, and is not freed until the <a href="Lucene.Net.Index.IndexReader.html">IndexReader</a> is closed. In contrast, TermsFilter has no persistent RAM consumption. <p xmlns="urn:ndoc-schema"></p> With each search, this filter translates the specified set of Terms into a private <a href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> keyed by term number per unique <b>IndexReader</b> (normally one reader per segment). Then, during matching, the term number for each docID is retrieved from the cache and then checked for inclusion using the <b>OpenBitSet</b>. Since all testing is done using RAM resident data structures, performance should be very fast, most likely fast enough to not require further caching of the DocIdSet for each possible combination of terms. However, because docIDs are simply scanned linearly, an index with a great many small documents may find this linear scan too costly. <p xmlns="urn:ndoc-schema"></p> In contrast, TermsFilter builds up an <b>OpenBitSet</b>, keyed by docID, every time it's created, by enumerating through all matching docs using <a href="Lucene.Net.Index.TermDocs.html">TermDocs</a> to seek and scan through each term's docID list. While there is no linear scan of all docIDs, besides the allocation of the underlying array in the <b>OpenBitSet</b>, this approach requires a number of "disk seeks" in proportion to the number of terms, which can be exceptionally costly when there are cache misses in the OS's IO cache. <p xmlns="urn:ndoc-schema"></p> Generally, this filter will be slower on the first invocation for a given field, but subsequent invocations, even if you change the allowed set of Terms, should be faster than TermsFilter, especially as the number of Terms being matched increases. If you are matching only a very small number of terms, and those terms in turn match a very small number of documents, TermsFilter may perform faster. <p xmlns="urn:ndoc-schema"></p> Which filter is best is very application dependent. <p>
                For a list of all members of this type, see <a href="Lucene.Net.Search.FieldCacheTermsFilter~Members.html">FieldCacheTermsFilter Members
                </a>.
              </p><p><a href="http://msdn.microsoft.com/en-us/library/System.Object(VS.100).aspx">System.Object</a><br />   <a href="Lucene.Net.Search.Filter.html">Filter</a><br />      <b>FieldCacheTermsFilter</b></p><div class="syntax"><div class="attribute">[Serializable]</div><div>public class FieldCacheTermsFilter<b> : <a href="Lucene.Net.Search.Filter.html">Filter</a></b></div></div><H4 class="dtH4">Thread Safety</H4><P>
					Public static (<b>Shared</b> in Visual Basic) members of this type are
					safe for multithreaded operations. Instance members are <b>not</b> guaranteed to be
					thread-safe.
				</P><h4 class="dtH4">Requirements</h4><p><b>Namespace: </b><a href="Lucene.Net.Search.html">Lucene.Net.Search</a></p><p><b>Assembly: </b>Lucene.Net (in Lucene.Net.dll)
          </p><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Search.FieldCacheTermsFilter~Members.html">FieldCacheTermsFilter Members</a> | <a href="Lucene.Net.Search.html">Lucene.Net.Search Namespace</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>