<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>Lucene.Net.Index</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">Lucene.Net.Index Namespace</h1></div></div><div id="nstext"><p><a href="Lucene.Net.Index~Hierarchy.html">Namespace Hierarchy</a></p><h3 class="dtH3">Classes</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Class</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.AbstractAllTermDocs.html">AbstractAllTermDocs</a></td><td width="50%"> Base class for enumerating all but deleted docs. <p xmlns="urn:ndoc-schema"></p>NOTE: this class is meant only to be used internally by Lucene; it's only public so it can be shared across packages. This means the API is freely subject to change, and, the class could be removed entirely, in any Lucene release. Use directly at your own risk! */ </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ByteBlockPool.html">ByteBlockPool</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ByteSliceReader.html">ByteSliceReader</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ByteSliceWriter.html">ByteSliceWriter</a></td><td width="50%"> Class to write byte streams into slices of shared byte[]. This is used by DocumentsWriter to hold the posting list for many terms in RAM. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CompoundFileReader.html">CompoundFileReader</a></td><td width="50%"> Class for accessing a compound stream. This class implements a directory, but is limited to only read operations. Directory methods that would normally modify data throw an exception. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CompoundFileReader.CSIndexInput.html">CompoundFileReader.CSIndexInput</a></td><td width="50%">Implementation of an IndexInput that reads from a portion of the compound file. The visibility is left as "package" *only* because this helps with testing since JUnit test cases in a different class can then access package fields of this class. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CompoundFileWriter.html">CompoundFileWriter</a></td><td width="50%"> Combines multiple files into a single compound file. The file format:<br xmlns:ndoc="urn:ndoc-schema" /><ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li>VInt fileCount</li><li>{Directory} fileCount entries with the following structure:</li><li>{File Data} fileCount entries with the raw data of the corresponding file</li></ul> The fileCount integer indicates how many files are contained in this compound file. The {directory} that follows has that many entries. Each directory entry contains a long pointer to the start of this file's data section, and a String with that file's name. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ConcurrentMergeScheduler.html">ConcurrentMergeScheduler</a></td><td width="50%">A <a href="Lucene.Net.Index.MergeScheduler.html">MergeScheduler</a> that runs each merge using a separate thread, up until a maximum number of threads (<a href="Lucene.Net.Index.ConcurrentMergeScheduler.MaxThreadCount.html">MaxThreadCount</a>) at which when a merge is needed, the thread(s) that are updating the index will pause until one or more merges completes. This is a simple way to use concurrency in the indexing process without having to create and manage application level threads. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.html">ConcurrentMergeScheduler.MergeThread</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CorruptIndexException.html">CorruptIndexException</a></td><td width="50%"> This exception is thrown when Lucene detects an inconsistency in the index. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.DirectoryReader.html">DirectoryReader</a></td><td width="50%"> An IndexReader which reads indexes with multiple segments.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.DocumentsWriter.html">DocumentsWriter</a></td><td width="50%"> This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments. Each added document is passed to the <b>DocConsumer</b>, which in turn processes the document and interacts with other consumers in the indexing chain. Certain consumers, like <b>StoredFieldsWriter</b> and <b>TermVectorsTermsWriter</b> , digest a document and immediately write bytes to the "doc store" files (ie, they do not consume RAM per document, except while they are processing the document). Other consumers, eg <b>FreqProxTermsWriter</b> and <b>NormsWriter</b>, buffer bytes in RAM and flush only when a new segment is produced. Once we have used our allowed RAM buffer, or the number of added docs is large enough (in the case we are flushing by doc count instead of RAM usage), we create a real segment and flush it to the Directory. Threads: Multiple threads are allowed into addDocument at once. There is an initial synchronized call to getThreadState which allocates a ThreadState for this thread. The same thread will get the same ThreadState over time (thread affinity) so that if there are consistent patterns (for example each thread is indexing a different content source) then we make better use of RAM. Then processDocument is called on that ThreadState without synchronization (most of the "heavy lifting" is in this call). Finally the synchronized "finishDocument" is called to flush changes to the directory. When flush is called by IndexWriter we forcefully idle all threads and flush only once they are all idle. This means you can call flush with a given thread even while other threads are actively adding/deleting documents. Exceptions: Because this class directly updates in-memory posting lists, and flushes stored fields and term vectors directly to files in the directory, there are certain limited times when an exception can corrupt this state. For example, a disk full while flushing stored fields leaves this file in a corrupt state. Or, an OOM exception while appending to the in-memory posting lists can corrupt that posting list. We call such exceptions "aborting exceptions". In these cases we must call abort() to discard all docs added since the last flush. All other exceptions ("non-aborting exceptions") can still partially update the index structures. These updates are consistent, but, they represent only a part of the document seen up until the exception was hit. When this happens, we immediately mark the document as deleted so that the document is always atomically ("all or none") added to the index. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FieldInfo.html">FieldInfo</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FieldInfos.html">FieldInfos</a></td><td width="50%">Access to the Fieldable Info file that describes document fields and whether or not they are indexed. Each segment has a separate Fieldable Info file. Objects of this class are thread-safe for multiple readers, but only one thread can be adding documents at a time, with no other reader or writer threads accessing this object. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FieldInvertState.html">FieldInvertState</a></td><td width="50%"> This class tracks the number and position / offset parameters of terms being added to the index. The information collected in this class is also used to calculate the normalization factor for a field. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: This API is new and experimental, and may suddenly change.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FieldReaderException.html">FieldReaderException</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FieldSortedTermVectorMapper.html">FieldSortedTermVectorMapper</a></td><td width="50%"> For each Field, store a sorted collection of <a href="Lucene.Net.Index.TermVectorEntry.html">TermVectorEntry</a>s <p xmlns="urn:ndoc-schema"></p> This is not thread-safe. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FieldsReader.html">FieldsReader</a></td><td width="50%"> Class responsible for access to stored document fields. <p xmlns="urn:ndoc-schema"></p> It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FilterIndexReader.html">FilterIndexReader</a></td><td width="50%">A <code xmlns:ndoc="urn:ndoc-schema">FilterIndexReader</code> contains another IndexReader, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality. The class <code xmlns:ndoc="urn:ndoc-schema">FilterIndexReader</code> itself simply implements all abstract methods of <code xmlns:ndoc="urn:ndoc-schema">IndexReader</code> with versions that pass all requests to the contained index reader. Subclasses of <code xmlns:ndoc="urn:ndoc-schema">FilterIndexReader</code> may further override some of these methods and may also provide additional methods and fields. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FilterIndexReader.FilterTermDocs.html">FilterIndexReader.FilterTermDocs</a></td><td width="50%">Base class for filtering <a href="Lucene.Net.Index.TermDocs.html">TermDocs</a> implementations. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FilterIndexReader.FilterTermEnum.html">FilterIndexReader.FilterTermEnum</a></td><td width="50%">Base class for filtering <a href="Lucene.Net.Index.TermEnum.html">TermEnum</a> implementations. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.FilterIndexReader.FilterTermPositions.html">FilterIndexReader.FilterTermPositions</a></td><td width="50%">Base class for filtering <a href="Lucene.Net.Index.FilterIndexReader.TermPositions1.html">TermPositions</a> implementations. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CheckIndex.html">CheckIndex</a></td><td width="50%"> Basic tool and API to check the health of an index and write a new segments file that removes reference to problematic segments. <p xmlns="urn:ndoc-schema"></p>As this tool checks every byte in the index, on a large index it can take quite a long time to run. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: this tool and API is new and experimental and is subject to suddenly change in the next release. Please make a complete backup of your index before using this to fix your index! </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CheckIndex.Status.html">CheckIndex.Status</a></td><td width="50%"> Returned from <a href="Lucene.Net.Index.CheckIndex.CheckIndex_Renamed_Method1.html">CheckIndex_Renamed_Method</a> detailing the health and status of the index. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: this API is new and experimental and is subject to suddenly change in the next release. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CheckIndex.Status.FieldNormStatus.html">CheckIndex.Status.FieldNormStatus</a></td><td width="50%"> Status from testing field norms.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.html">CheckIndex.Status.SegmentInfoStatus</a></td><td width="50%">Holds the status of each segment in the index. See <a href="Lucene.Net.Index.SegmentInfos.html">SegmentInfos</a>. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: this API is new and experimental and is subject to suddenly change in the next release. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.html">CheckIndex.Status.StoredFieldStatus</a></td><td width="50%"> Status from testing stored fields.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.html">CheckIndex.Status.TermIndexStatus</a></td><td width="50%"> Status from testing term index.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.html">CheckIndex.Status.TermVectorStatus</a></td><td width="50%"> Status from testing stored fields.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexCommit.html">IndexCommit</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Expert: represents a single commit into an index as seen by the <a href="Lucene.Net.Index.IndexDeletionPolicy.html">IndexDeletionPolicy</a> or <a href="Lucene.Net.Index.IndexReader.html">IndexReader</a>.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p> Changes to the content of an index are made visible only after the writer who made that change commits by writing a new segments file (<code xmlns:ndoc="urn:ndoc-schema">segments_N</code>). This point in time, when the action of writing of a new segments file to the directory is completed, is an index commit.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Each index commit point has a unique segments file associated with it. The segments file associated with a later index commit point would have a larger N.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: This API is a new and experimental and may suddenly change. <p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexFileDeleter.html">IndexFileDeleter</a></td><td width="50%"><p xmlns:ndoc="urn:ndoc-schema">This class keeps track of each SegmentInfos instance that is still "live", either because it corresponds to a segments_N file in the Directory (a "commit", i.e. a committed SegmentInfos) or because it's an in-memory SegmentInfos that a writer is actively updating but has not yet committed. This class uses simple reference counting to map the live SegmentInfos instances to individual files in the Directory.</p><p xmlns:ndoc="urn:ndoc-schema">The same directory file may be referenced by more than one IndexCommit, i.e. more than one SegmentInfos. Therefore we count how many commits reference each file. When all the commits referencing a certain file have been deleted, the refcount for that file becomes zero, and the file is deleted.</p><p xmlns:ndoc="urn:ndoc-schema">A separate deletion policy interface (IndexDeletionPolicy) is consulted on creation (onInit) and once per commit (onCommit), to decide when a commit should be removed.</p><p xmlns:ndoc="urn:ndoc-schema">It is the business of the IndexDeletionPolicy to choose when to delete commit points. The actual mechanics of file deletion, retrying, etc, derived from the deletion of commit points is the business of the IndexFileDeleter.</p><p xmlns:ndoc="urn:ndoc-schema">The current default deletion policy is <a href="Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.html">KeepOnlyLastCommitDeletionPolicy</a>, which removes all prior commits when a new commit has completed. This matches the behavior before 2.2.</p><p xmlns:ndoc="urn:ndoc-schema">Note that you must hold the write.lock before instantiating this class. It opens segments_N file(s) directly with no retry logic.</p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexFileNameFilter.html">IndexFileNameFilter</a></td><td width="50%">Filename filter that accept filenames and extensions only created by Lucene. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexFileNames.html">IndexFileNames</a></td><td width="50%">Useful constants representing filenames and extensions used by lucene</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexReader.html">IndexReader</a></td><td width="50%">IndexReader is an abstract class, providing an interface for accessing an index. Search of an index is done entirely through this abstract interface, so that any subclass which implements it is searchable. <p xmlns="urn:ndoc-schema"></p> Concrete subclasses of IndexReader are usually constructed with a call to one of the static <code xmlns:ndoc="urn:ndoc-schema">open()</code> methods, e.g. <a href="Lucene.Net.Index.IndexReader.Open1.html">Open</a> . <p xmlns="urn:ndoc-schema"></p> For efficiency, in this API documents are often referred to via <i xmlns="urn:ndoc-schema">document numbers</i>, non-negative integers which each name a unique document in the index. These document numbers are ephemeral--they may change as documents are added to and deleted from an index. Clients should thus not rely on a given document having the same number between sessions. <p xmlns="urn:ndoc-schema"></p> An IndexReader can be opened on a directory for which an IndexWriter is opened already, but it cannot be used to delete documents from the index then. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: for backwards API compatibility, several methods are not listed as abstract, but have no useful implementations in this base class and instead always throw UnsupportedOperationException. Subclasses are strongly encouraged to override these methods, but in many cases may not need to. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: as of 2.4, it's possible to open a read-only IndexReader using the static open methods that accepts the boolean readOnly parameter. Such a reader has better better concurrency as it's not necessary to synchronize on the isDeleted method. You must explicitly specify false if you want to make changes with the resulting IndexReader. <p xmlns="urn:ndoc-schema"></p><a name="thread-safety" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: <b xmlns:ndoc="urn:ndoc-schema">IndexReader</b> instances are completely thread safe, meaning multiple threads can call any of its methods, concurrently. If your application requires external synchronization, you should <b xmlns="urn:ndoc-schema">not</b> synchronize on the <code xmlns:ndoc="urn:ndoc-schema">IndexReader</code> instance; use your own (non-Lucene) objects instead. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexReader.FieldOption.html">IndexReader.FieldOption</a></td><td width="50%"> Constants describing field properties, for example used for <a href="Lucene.Net.Index.IndexReader.GetFieldNames.html">GetFieldNames</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a></td><td width="50%">An <code xmlns:ndoc="urn:ndoc-schema">IndexWriter</code> creates and maintains an index. <p xmlns="urn:ndoc-schema"></p>The <code xmlns:ndoc="urn:ndoc-schema">create</code> argument to the <a href="Lucene.Net.Index.IndexWriter.~ctor1.html">constructor</a> determines whether a new index is created, or whether an existing index is opened. Note that you can open an index with <code xmlns:ndoc="urn:ndoc-schema">create=true</code> even while readers are using the index. The old readers will continue to search the "point in time" snapshot they had opened, and won't see the newly created index until they re-open. There are also <a href="Lucene.Net.Index.IndexWriter.~ctor2.html">constructors</a> with no <code xmlns:ndoc="urn:ndoc-schema">create</code> argument which will create a new index if there is not already an index at the provided path and otherwise open the existing index.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>In either case, documents are added with <a href="Lucene.Net.Index.IndexWriter.AddDocument1.html">AddDocument</a> and removed with <a href="Lucene.Net.Index.IndexWriter.DeleteDocuments1.html">DeleteDocuments</a> or <a href="Lucene.Net.Index.IndexWriter.DeleteDocuments3.html">DeleteDocuments</a>. A document can be updated with <a href="Lucene.Net.Index.IndexWriter.UpdateDocument1.html">UpdateDocument</a> (which just deletes and then adds the entire document). When finished adding, deleting and updating documents, <a href="Lucene.Net.Index.IndexWriter.Close1.html">Close</a> should be called.<p xmlns="urn:ndoc-schema"></p><a name="flush" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p>These changes are buffered in memory and periodically flushed to the <a href="Lucene.Net.Index.IndexWriter.Directory.html">Directory</a> (during the above method calls). A flush is triggered when there are enough buffered deletes (see <a href="Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms.html">SetMaxBufferedDeleteTerms</a>) or enough added documents since the last flush, whichever is sooner. For the added documents, flushing is triggered either by RAM usage of the documents (see <a href="Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB.html">SetRAMBufferSizeMB</a>) or the number of added documents. The default is to flush when RAM usage hits 16 MB. For best indexing speed you should flush by RAM usage with a large RAM buffer. Note that flushing just moves the internal buffered state in IndexWriter into the index, but these changes are not visible to IndexReader until either <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a> or <b xmlns:ndoc="urn:ndoc-schema">Close</b> is called. A flush may also trigger one or more segment merges which by default run with a background thread so as not to block the addDocument calls (see <a href="#mergePolicy" xmlns="urn:ndoc-schema">below</a> for changing the <a href="Lucene.Net.Index.IndexWriter.MergeScheduler.html">MergeScheduler</a>). <p xmlns="urn:ndoc-schema"></p> If an index will not have more documents added for a while and optimal search performance is desired, then either the full <a href="Lucene.Net.Index.IndexWriter.Optimize1.html">Optimize</a> method or partial <a href="Lucene.Net.Index.IndexWriter.Optimize2.html">Optimize</a> method should be called before the index is closed. <p xmlns="urn:ndoc-schema"></p> Opening an <code xmlns:ndoc="urn:ndoc-schema">IndexWriter</code> creates a lock file for the directory in use. Trying to open another <code xmlns:ndoc="urn:ndoc-schema">IndexWriter</code> on the same directory will lead to a <a href="Lucene.Net.Store.LockObtainFailedException.html">LockObtainFailedException</a>. The <b xmlns:ndoc="urn:ndoc-schema">LockObtainFailedException</b> is also thrown if an IndexReader on the same directory is used to delete documents from the index.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexWriter.IndexReaderWarmer.html">IndexWriter.IndexReaderWarmer</a></td><td width="50%">If <a href="Lucene.Net.Index.IndexWriter.GetReader1.html">GetReader</a> has been called (ie, this writer is in near real-time mode), then after a merge completes, this class can be invoked to warm the reader on the newly merged segment, before the merge commits. This is not required for near real-time search, but will reduce search latency on opening a new near real-time reader after a merge completes. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is experimental and might change in incompatible ways in the next release.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: warm is called before any deletes have been carried over to the merged segment. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexWriter.MaxFieldLength.html">IndexWriter.MaxFieldLength</a></td><td width="50%"> Specifies maximum field length (in number of tokens/terms) in <a href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a> constructors. <a href="Lucene.Net.Index.IndexWriter.SetMaxFieldLength.html">SetMaxFieldLength</a> overrides the value set by the constructor. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.html">KeepOnlyLastCommitDeletionPolicy</a></td><td width="50%"> This <a href="Lucene.Net.Index.IndexDeletionPolicy.html">IndexDeletionPolicy</a> implementation that keeps only the most recent commit and immediately removes all prior commits after a new commit is done. This is the default deletion policy. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.LogByteSizeMergePolicy.html">LogByteSizeMergePolicy</a></td><td width="50%">This is a <a href="Lucene.Net.Index.LogMergePolicy.html">LogMergePolicy</a> that measures size of a segment as the total byte size of the segment's files. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.LogDocMergePolicy.html">LogDocMergePolicy</a></td><td width="50%">This is a <a href="Lucene.Net.Index.LogMergePolicy.html">LogMergePolicy</a> that measures size of a segment as the number of documents (not taking deletions into account). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.LogMergePolicy.html">LogMergePolicy</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>This class implements a <a href="Lucene.Net.Index.MergePolicy.html">MergePolicy</a> that tries to merge segments into levels of exponentially increasing size, where each level has fewer segments than the value of the merge factor. Whenever extra segments (beyond the merge factor upper bound) are encountered, all segments within the level are merged. You can get or set the merge factor using <a href="Lucene.Net.Index.LogMergePolicy.MergeFactor.html">MergeFactor</a> and <b xmlns:ndoc="urn:ndoc-schema">MergeFactor</b> respectively.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>This class is abstract and requires a subclass to define the <a href="Lucene.Net.Index.LogMergePolicy.Size.html">Size</a> method which specifies how a segment's size is determined. <a href="Lucene.Net.Index.LogDocMergePolicy.html">LogDocMergePolicy</a> is one subclass that measures size by document count in the segment. <a href="Lucene.Net.Index.LogByteSizeMergePolicy.html">LogByteSizeMergePolicy</a> is another subclass that measures size as the total byte size of the file(s) for the segment.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MergePolicy.html">MergePolicy</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall merge and optimize operations.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Whenever the segments in an index have been altered by <a href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a>, either the addition of a newly flushed segment, addition of many segments from addIndexes* calls, or a previous merge that may now need to cascade, <b xmlns:ndoc="urn:ndoc-schema">IndexWriter</b> invokes <a href="Lucene.Net.Index.MergePolicy.FindMerges.html">FindMerges</a> to give the MergePolicy a chance to pick merges that are now required. This method returns a <a href="Lucene.Net.Index.MergePolicy.MergeSpecification.html">MergePolicy.MergeSpecification</a> instance describing the set of merges that should be done, or null if no merges are necessary. When IndexWriter.optimize is called, it calls <a href="Lucene.Net.Index.MergePolicy.FindMergesForOptimize.html">FindMergesForOptimize</a> and the MergePolicy should then return the necessary merges.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Note that the policy can return more than one merge at a time. In this case, if the writer is using <a href="Lucene.Net.Index.SerialMergeScheduler.html">SerialMergeScheduler</a> , the merges will be run sequentially but if it is using <a href="Lucene.Net.Index.ConcurrentMergeScheduler.html">ConcurrentMergeScheduler</a> they will be run concurrently.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>The default MergePolicy is <a href="Lucene.Net.Index.LogByteSizeMergePolicy.html">LogByteSizeMergePolicy</a> .<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is new and still experimental (subject to change suddenly in the next release)<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: This class typically requires access to package-private APIs (e.g. <code xmlns:ndoc="urn:ndoc-schema">SegmentInfos</code>) to do its job; if you implement your own MergePolicy, you'll need to put it in package Lucene.Net.Index in order to use these APIs. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MergePolicy.MergeAbortedException.html">MergePolicy.MergeAbortedException</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MergePolicy.MergeException.html">MergePolicy.MergeException</a></td><td width="50%">Exception thrown if there are any problems while executing a merge. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MergePolicy.MergeSpecification.html">MergePolicy.MergeSpecification</a></td><td width="50%"> A MergeSpecification instance provides the information necessary to perform multiple merges. It simply contains a list of <a href="Lucene.Net.Index.MergePolicy.OneMerge.html">MergePolicy.OneMerge</a> instances. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MergePolicy.OneMerge.html">MergePolicy.OneMerge</a></td><td width="50%">OneMerge provides the information necessary to perform an individual primitive merge operation, resulting in a single new segment. The merge spec includes the subset of segments to be merged as well as whether the new segment should use the compound file format. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MergeScheduler.html">MergeScheduler</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Expert: <a href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a> uses an instance implementing this interface to execute the merges selected by a <a href="Lucene.Net.Index.MergePolicy.html">MergePolicy</a>. The default MergeScheduler is <a href="Lucene.Net.Index.ConcurrentMergeScheduler.html">ConcurrentMergeScheduler</a>.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is new and still experimental (subject to change suddenly in the next release)<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: This class typically requires access to package-private APIs (eg, SegmentInfos) to do its job; if you implement your own MergePolicy, you'll need to put it in package Lucene.Net.Index in order to use these APIs. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MultipleTermPositions.html">MultipleTermPositions</a></td><td width="50%"> Allows you to iterate over the <a href="Lucene.Net.Index.TermPositions.html">TermPositions</a> for multiple <a href="Lucene.Net.Index.Term.html">Term</a>s as a single <b xmlns:ndoc="urn:ndoc-schema">TermPositions</b>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.MultiReader.html">MultiReader</a></td><td width="50%">An IndexReader which reads multiple indexes, appending their content. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ParallelReader.html">ParallelReader</a></td><td width="50%">An IndexReader which reads multiple, parallel indexes. Each index added must have the same number of documents, but typically each contains different fields. Each document contains the union of the fields of all documents with the same document number. When searching, matches for a query term are from the first index added that has the field. <p xmlns="urn:ndoc-schema"></p>This is useful, e.g., with collections that have large fields which change rarely and small fields that change more frequently. The smaller fields may be re-indexed in a new index and both indexes may be searched together. <p xmlns="urn:ndoc-schema"></p><strong xmlns="urn:ndoc-schema">Warning:</strong> It is up to you to make sure all indexes are created and modified the same way. For example, if you add documents to one index, you need to add the same documents in the same order to the other indexes. <em xmlns="urn:ndoc-schema">Failure to do so will result in undefined behavior</em>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.Payload.html">Payload</a></td><td width="50%"> A Payload is metadata that can be stored together with each occurrence of a term. This metadata is stored inline in the posting list of the specific term. <p xmlns="urn:ndoc-schema"></p> To store payloads in the index a <a href="Lucene.Net.Analysis.TokenStream.html">TokenStream</a> has to be used that produces payload data. <p xmlns="urn:ndoc-schema"></p> Use <a href="Lucene.Net.Index.TermPositions.PayloadLength.html">PayloadLength</a> and <a href="Lucene.Net.Index.TermPositions.GetPayload.html">GetPayload</a> to retrieve the payloads from the index.<br xmlns:ndoc="urn:ndoc-schema" /></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.PositionBasedTermVectorMapper.html">PositionBasedTermVectorMapper</a></td><td width="50%"> For each Field, store position by position information. It ignores frequency information <p xmlns="urn:ndoc-schema"></p> This is not thread-safe. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo.html">PositionBasedTermVectorMapper.TVPositionInfo</a></td><td width="50%"> Container for a term at a position</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ReadOnlyDirectoryReader.html">ReadOnlyDirectoryReader</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ReadOnlySegmentReader.html">ReadOnlySegmentReader</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentInfo.html">SegmentInfo</a></td><td width="50%"> Information about a segment such as it's name, directory, and files related to the segment. * <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is new and still experimental (subject to change suddenly in the next release)<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentInfos.html">SegmentInfos</a></td><td width="50%"> A collection of segmentInfo objects with methods for operating on those segments in relation to the file system. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is new and still experimental (subject to change suddenly in the next release)<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentInfos.FindSegmentsFile.html">SegmentInfos.FindSegmentsFile</a></td><td width="50%"> Utility class for executing code that needs to do something with the current segments file. This is necessary with lock-less commits because from the time you locate the current segments file name, until you actually open it, read its contents, or check modified time, etc., it could have been deleted due to a writer commit finishing. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentMerger.html">SegmentMerger</a></td><td width="50%"> The SegmentMerger class combines two or more Segments, represented by an IndexReader (<a href="Lucene.Net.Index.SegmentMerger.Add.html">Add</a>, into a single Segment. After adding the appropriate readers, call the merge method to combine the segments. <p xmlns="urn:ndoc-schema"></p> If the compoundFile flag is set, then the segments will be merged into a compound file. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentReader.html">SegmentReader</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is new and still experimental (subject to change suddenly in the next release)<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentReader.CoreReaders.html">SegmentReader.CoreReaders</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentReader.Norm.html">SegmentReader.Norm</a></td><td width="50%"> Byte[] referencing is used because a new norm object needs to be created for each clone, and the byte array is all that is needed for sharing between cloned readers. The current norm referencing is for sharing between readers whereas the byte[] referencing is for copy on write which is independent of reader references (i.e. incRef, decRef). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SegmentReader.Ref.html">SegmentReader.Ref</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SerialMergeScheduler.html">SerialMergeScheduler</a></td><td width="50%">A <a href="Lucene.Net.Index.MergeScheduler.html">MergeScheduler</a> that simply does each merge sequentially, using the current thread. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SnapshotDeletionPolicy.html">SnapshotDeletionPolicy</a></td><td width="50%">A <a href="Lucene.Net.Index.IndexDeletionPolicy.html">IndexDeletionPolicy</a> that wraps around any other <b xmlns:ndoc="urn:ndoc-schema">IndexDeletionPolicy</b> and adds the ability to hold and later release a single "snapshot" of an index. While the snapshot is held, the <a href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a> will not remove any files associated with it even if the index is otherwise being actively, arbitrarily changed. Because we wrap another arbitrary <b xmlns:ndoc="urn:ndoc-schema">IndexDeletionPolicy</b>, this gives you the freedom to continue using whatever <b xmlns:ndoc="urn:ndoc-schema">IndexDeletionPolicy</b> you would normally want to use with your index. Note that you can re-use a single instance of SnapshotDeletionPolicy across multiple writers as long as they are against the same index Directory. Any snapshot held when a writer is closed will "survive" when the next writer is opened. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">WARNING</b>: This API is a new and experimental and may suddenly change.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.SortedTermVectorMapper.html">SortedTermVectorMapper</a></td><td width="50%"> Store a sorted collection of <a href="Lucene.Net.Index.TermVectorEntry.html">TermVectorEntry</a>s. Collects all term information into a single, SortedSet. <br xmlns:ndoc="urn:ndoc-schema" /> NOTE: This Mapper ignores all Field information for the Document. This means that if you are using offset/positions you will not know what Fields they correlate with. <br xmlns:ndoc="urn:ndoc-schema" /> This is not thread-safe </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.StaleReaderException.html">StaleReaderException</a></td><td width="50%"> This exception is thrown when an <a href="Lucene.Net.Index.IndexReader.html">IndexReader</a> tries to make changes to the index (via <a href="Lucene.Net.Index.IndexReader.DeleteDocument.html">DeleteDocument</a> , <a href="Lucene.Net.Index.IndexReader.UndeleteAll.html">UndeleteAll</a> or <a href="Lucene.Net.Index.IndexReader.SetNorm2.html">SetNorm</a>) but changes have already been committed to the index since this reader was instantiated. When this happens you must open a new reader on the current index to make the changes. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.Term.html">Term</a></td><td width="50%">A Term represents a word from text. This is the unit of search. It is composed of two elements, the text of the word, as a string, and the name of the field that the text occured in, an interned string. Note that terms may represent more than words from text fields, but also things like dates, email addresses, urls, etc. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermEnum.html">TermEnum</a></td><td width="50%">Abstract class for enumerating terms. <p xmlns="urn:ndoc-schema"></p>Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermVectorEntry.html">TermVectorEntry</a></td><td width="50%"> Convenience class for holding TermVector information.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermVectorEntryFreqSortedComparator.html">TermVectorEntryFreqSortedComparator</a></td><td width="50%"> Compares <a href="Lucene.Net.Index.TermVectorEntry.html">TermVectorEntry</a>s first by frequency and then by the term (case-sensitive) </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermVectorMapper.html">TermVectorMapper</a></td><td width="50%"> The TermVectorMapper can be used to map Term Vectors into your own structure instead of the parallel array structure used by <a href="Lucene.Net.Index.IndexReader.GetTermFreqVector1.html">GetTermFreqVector</a>. <p xmlns="urn:ndoc-schema"></p> It is up to the implementation to make sure it is thread-safe. </td></tr></table></div><h3 class="dtH3">Interfaces</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Interface</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.IndexDeletionPolicy.html">IndexDeletionPolicy</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Expert: policy for deletion of stale <a href="Lucene.Net.Index.IndexCommit.html">index commits</a>. <p xmlns="urn:ndoc-schema"></p>Implement this interface, and pass it to one of the <a href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a> or <a href="Lucene.Net.Index.IndexReader.html">IndexReader</a> constructors, to customize when older <b xmlns:ndoc="urn:ndoc-schema">point-in-time commits</b> are deleted from the index directory. The default deletion policy is <a href="Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.html">KeepOnlyLastCommitDeletionPolicy</a>, which always removes old commits as soon as a new commit is done (this matches the behavior before 2.2).<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>One expected use case for this (and the reason why it was first created) is to work around problems with an index directory accessed via filesystems like NFS because NFS does not provide the "delete on last close" semantics that Lucene's "point in time" search normally relies on. By implementing a custom deletion policy, such as "a commit is only removed once it has been stale for more than X minutes", you can give your readers time to refresh to the new commit before <b xmlns:ndoc="urn:ndoc-schema">IndexWriter</b> removes the old commits. Note that doing so will increase the storage requirements of the index. See <a target="top" href="http://issues.apache.org/jira/browse/LUCENE-710" xmlns="urn:ndoc-schema">LUCENE-710</a> for details.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.ITermFreqVector.html">ITermFreqVector</a></td><td width="50%">Provides access to stored term vector of a document field. The vector consists of the name of the field, an array of the terms tha occur in the field of the <a href="Lucene.Net.Documents.Document.html">Document</a> and a parallel array of frequencies. Thus, getTermFrequencies()[5] corresponds with the frequency of getTerms()[5], assuming there are at least 5 terms in the Document. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermDocs.html">TermDocs</a></td><td width="50%">TermDocs provides an interface for enumerating &lt;document, frequency&gt; pairs for a term. <p xmlns="urn:ndoc-schema"></p> The document portion names each document containing the term. Documents are indicated by number. The frequency portion gives the number of times the term occurred in each document. <p xmlns="urn:ndoc-schema"></p> The pairs are ordered by document number. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermPositions.html">TermPositions</a></td><td width="50%"> TermPositions provides an interface for enumerating the &lt;document, frequency, &lt;position&gt;* &gt; tuples for a term. <p xmlns="urn:ndoc-schema"></p> The document and frequency are the same as for a TermDocs. The positions portion lists the ordinal positions of each occurrence of a term in a document. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermPositionVector.html">TermPositionVector</a></td><td width="50%">Extends <code xmlns:ndoc="urn:ndoc-schema">TermFreqVector</code> to provide additional information about positions in which each of the terms is found. A TermPositionVector not necessarily contains both positions and offsets, but at least one of these arrays exists. </td></tr></table></div><h3 class="dtH3">Structures</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Structure</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Index.TermVectorOffsetInfo.html">TermVectorOffsetInfo</a></td><td width="50%"> The TermVectorOffsetInfo class holds information pertaining to a Term in a <a href="Lucene.Net.Index.TermPositionVector.html">TermPositionVector</a>'s offset information. This offset information is the character offset as set during the Analysis phase (and thus may not be the actual offset in the original content). </td></tr></table></div></div></body></html>