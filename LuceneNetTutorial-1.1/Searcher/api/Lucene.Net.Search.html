<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>Lucene.Net.Search</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">Lucene.Net.Search Namespace</h1></div></div><div id="nstext"><p><a href="Lucene.Net.Search~Hierarchy.html">Namespace Hierarchy</a></p><h3 class="dtH3">Classes</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Class</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.BooleanClause.html">BooleanClause</a></td><td width="50%">A clause in a BooleanQuery. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.BooleanQuery.html">BooleanQuery</a></td><td width="50%">A Query that matches documents matching boolean combinations of other queries, e.g. <a href="Lucene.Net.Search.TermQuery.html">TermQuery</a>s, <a href="Lucene.Net.Search.PhraseQuery.html">PhraseQuery</a>s or other BooleanQuerys. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.BooleanQuery.BooleanWeight.html">BooleanQuery.BooleanWeight</a></td><td width="50%"> Expert: the Weight for BooleanQuery, used to normalize, score and explain these queries. <p xmlns="urn:ndoc-schema"></p>NOTE: this API and implementation is subject to change suddenly in the next release.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.BooleanQuery.TooManyClauses.html">BooleanQuery.TooManyClauses</a></td><td width="50%">Thrown when an attempt is made to add more than <a href="Lucene.Net.Search.BooleanQuery.MaxClauseCount.html">MaxClauseCount</a> clauses. This typically happens if a PrefixQuery, FuzzyQuery, WildcardQuery, or TermRangeQuery is expanded to many terms during search. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.BooleanScorer.html">BooleanScorer</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.CacheEntry.html">CacheEntry</a></td><td width="50%"> EXPERT: A unique Identifier/Description for each item in the FieldCache. Can be useful for logging/debugging. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">EXPERIMENTAL API:</b> This API is considered extremely advanced and experimental. It may be removed or altered w/o warning in future releases of Lucene. <p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.CachingSpanFilter.html">CachingSpanFilter</a></td><td width="50%"> Wraps another SpanFilter's result and caches it. The purpose is to allow filters to simply filter, and then wrap with this class to add caching. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.CachingWrapperFilter.html">CachingWrapperFilter</a></td><td width="50%"> Wraps another filter's result and caches it. The purpose is to allow filters to simply filter, and then wrap with this class to add caching. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Collector.html">Collector</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Expert: Collectors are primarily meant to be used to gather raw results from a search, and implement sorting or custom result filtering, collation, etc. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Lucene's core collectors are derived from Collector. Likely your application can use one of these classes, or subclass <a href="Lucene.Net.Search.TopDocsCollector$1.html">TopDocsCollector(T)</a>, instead of implementing Collector directly: <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li><b>TopDocsCollector(T)</b> is an abstract base class that assumes you will retrieve the top N docs, according to some criteria, after collection is done. </li><li><a href="Lucene.Net.Search.TopScoreDocCollector.html">TopScoreDocCollector</a> is a concrete subclass <b>TopDocsCollector(T)</b> and sorts according to score + docID. This is used internally by the <a href="Lucene.Net.Search.IndexSearcher.html">IndexSearcher</a> search methods that do not take an explicit <a href="Lucene.Net.Search.Sort.html">Sort</a>. It is likely the most frequently used collector.</li><li><a href="Lucene.Net.Search.TopFieldCollector.html">TopFieldCollector</a> subclasses <b>TopDocsCollector(T)</b> and sorts according to a specified <b>Sort</b> object (sort by field). This is used internally by the <b>IndexSearcher</b> search methods that take an explicit <b>Sort</b>.</li><li><a href="Lucene.Net.Search.TimeLimitingCollector.html">TimeLimitingCollector</a>, which wraps any other Collector and aborts the search if it's taken too much time.</li><li><a href="Lucene.Net.Search.PositiveScoresOnlyCollector.html">PositiveScoresOnlyCollector</a> wraps any other Collector and prevents collection of hits whose score is &lt;= 0.0</li></ul><p xmlns="urn:ndoc-schema"></p>Collector decouples the score from the collected doc: the score computation is skipped entirely if it's not needed. Collectors that do need the score should implement the <a href="Lucene.Net.Search.Collector.SetScorer.html">SetScorer</a> method, to hold onto the passed <a href="Lucene.Net.Search.Scorer.html">Scorer</a> instance, and call <a href="Lucene.Net.Search.Scorer.Score3.html">Score</a> within the collect method to compute the current hit's score. If your collector may request the score for a single hit multiple times, you should use <a href="Lucene.Net.Search.ScoreCachingWrappingScorer.html">ScoreCachingWrappingScorer</a>. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> The doc that is passed to the collect method is relative to the current reader. If your collector needs to resolve this to the docID space of the Multi*Reader, you must re-base it by recording the docBase from the most recent setNextReader call. Here's a simple example showing how to collect docIDs into a BitSet:<p xmlns="urn:ndoc-schema"></p><pre class="code" xmlns:ndoc="urn:ndoc-schema">Searcher searcher = new IndexSearcher(indexReader);
final BitSet bits = new BitSet(indexReader.MaxDoc);
searcher.search(query, new Collector() {
private int docBase;

<em xmlns="urn:ndoc-schema">// ignore scorer</em>
public void setScorer(Scorer scorer) {
}

<em xmlns="urn:ndoc-schema">// accept docs out of order (for a BitSet it doesn't matter)</em>
public boolean acceptsDocsOutOfOrder() {
return true;
}

public void collect(int doc) {
bits.set(doc + docBase);
}

public void setNextReader(IndexReader reader, int docBase) {
this.docBase = docBase;
}
});
</pre><p xmlns="urn:ndoc-schema"></p>Not all collectors will need to rebase the docID. For example, a collector that simply counts the total number of hits would skip it.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> Prior to 2.9, Lucene silently filtered out hits with score &lt;= 0. As of 2.9, the core Collectors no longer do that. It's very unusual to have such hits (a negative query boost, or function query returning negative custom scores, could cause it to happen). If you need that behavior, use <b xmlns:ndoc="urn:ndoc-schema">PositiveScoresOnlyCollector</b> .<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is experimental and might change in incompatible ways in the next release.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ComplexExplanation.html">ComplexExplanation</a></td><td width="50%">Expert: Describes the score computation for document and query, and can distinguish a match independent of a positive value. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ConstantScoreQuery.html">ConstantScoreQuery</a></td><td width="50%"> A query that wraps a filter and simply returns a constant score equal to the query boost for every document in the filter. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ConstantScoreQuery.ConstantScorer.html">ConstantScoreQuery.ConstantScorer</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ConstantScoreQuery.ConstantWeight.html">ConstantScoreQuery.ConstantWeight</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.CreationPlaceholder.html">CreationPlaceholder</a></td><td width="50%"> Expert: Maintains caches of term values. <p xmlns="urn:ndoc-schema"></p>Created: May 19, 2004 11:13:14 AM </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DefaultSimilarity.html">DefaultSimilarity</a></td><td width="50%">Expert: Default scoring implementation. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DisjunctionMaxQuery.html">DisjunctionMaxQuery</a></td><td width="50%"> A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries. This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be combined equivalently into a single search field). We want the primary score to be the one associated with the highest boost, not the sum of the field scores (as BooleanQuery would give). If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching another gets a higher score than "albino" matching both fields. To get this result, use both BooleanQuery and DisjunctionMaxQuery: for each term a DisjunctionMaxQuery searches for it in each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery. The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that include this term in only the best of those multiple fields, without confusing this with the better case of two different terms in the multiple fields. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.html">DisjunctionMaxQuery.DisjunctionMaxWeight</a></td><td width="50%"> Expert: the Weight for DisjunctionMaxQuery, used to normalize, score and explain these queries. <p xmlns="urn:ndoc-schema"></p>NOTE: this API and implementation is subject to change suddenly in the next release.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a></td><td width="50%"> A DocIdSet contains a set of doc ids. Implementing classes must only implement <a href="Lucene.Net.Search.DocIdSet.Iterator.html">Iterator</a> to provide access to the set. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DocIdSet.AnonymousClassDocIdSet.html">DocIdSet.AnonymousClassDocIdSet</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DocIdSet.AnonymousClassDocIdSet.AnonymousClassDocIdSetIterator.html">DocIdSet.AnonymousClassDocIdSet.AnonymousClassDocIdSetIterator</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a></td><td width="50%"> This abstract class defines methods to iterate over a set of non-decreasing doc ids. Note that this class assumes it iterates on doc Ids, and therefore <a href="Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS.html">NO_MORE_DOCS</a> is set to Int32.MaxValue in order to be used as a sentinel object. Implementations of this class are expected to consider <a href="http://msdn.microsoft.com/en-us/library/System.Int32.MaxValue(VS.100).aspx">MaxValue</a> as an invalid value. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Explanation.html">Explanation</a></td><td width="50%">Expert: Describes the score computation for document and query. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Explanation.IDFExplanation.html">Explanation.IDFExplanation</a></td><td width="50%"> Small Util class used to pass both an idf factor as well as an explanation for that factor. This class will likely be held on a <a href="Lucene.Net.Search.Weight.html">Weight</a>, so be aware before storing any large or un-serializable fields. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldCacheRangeFilter.html">FieldCacheRangeFilter</a></td><td width="50%"> A range filter built on top of a cached single term field (in <a href="Lucene.Net.Search.FieldCache.html">FieldCache</a>). <p xmlns="urn:ndoc-schema"></p><b xmlns:ndoc="urn:ndoc-schema">FieldCacheRangeFilter</b> builds a single cache for the field the first time it is used. Each subsequent <b xmlns:ndoc="urn:ndoc-schema">FieldCacheRangeFilter</b> on the same field then reuses this cache, even if the range itself changes. <p xmlns="urn:ndoc-schema"></p>This means that <b xmlns:ndoc="urn:ndoc-schema">FieldCacheRangeFilter</b> is much faster (sometimes more than 100x as fast) as building a <a href="Lucene.Net.Search.TermRangeFilter.html">TermRangeFilter</a> if using a <a href="Lucene.Net.Search.FieldCacheRangeFilter.NewStringRange.html">NewStringRange</a>. However, if the range never changes it is slower (around 2x as slow) than building a CachingWrapperFilter on top of a single <b xmlns:ndoc="urn:ndoc-schema">TermRangeFilter</b>. For numeric data types, this filter may be significantly faster than <a href="Lucene.Net.Search.NumericRangeFilter$1.html">NumericRangeFilter(T)</a>. Furthermore, it does not need the numeric values encoded by <a href="Lucene.Net.Documents.NumericField.html">NumericField</a>. But it has the problem that it only works with exact one value/document (see below). <p xmlns="urn:ndoc-schema"></p>As with all <b xmlns:ndoc="urn:ndoc-schema">FieldCache</b> based functionality, <b xmlns:ndoc="urn:ndoc-schema">FieldCacheRangeFilter</b> is only valid for fields which exact one term for each document (except for <b xmlns:ndoc="urn:ndoc-schema">NewStringRange</b> where 0 terms are also allowed). Due to a restriction of <b xmlns:ndoc="urn:ndoc-schema">FieldCache</b>, for numeric ranges all terms that do not have a numeric value, 0 is assumed. <p xmlns="urn:ndoc-schema"></p>Thus it works on dates, prices and other single value fields but will not work on regular text fields. It is preferable to use a <code xmlns:ndoc="urn:ndoc-schema">NOT_ANALYZED</code> field to ensure that there is only a single term. <p xmlns="urn:ndoc-schema"></p>This class does not have an constructor, use one of the static factory methods available, that create a correct instance for different data types supported by <b xmlns:ndoc="urn:ndoc-schema">FieldCache</b>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldCacheRangeFilter$1.html">FieldCacheRangeFilter(T)</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldCacheTermsFilter.html">FieldCacheTermsFilter</a></td><td width="50%"> A <a href="Lucene.Net.Search.Filter.html">Filter</a> that only accepts documents whose single term value in the specified field is contained in the provided set of allowed terms. <p xmlns="urn:ndoc-schema"></p> This is the same functionality as TermsFilter (from contrib/queries), except this filter requires that the field contains only a single term for all documents. Because of drastically different implementations, they also have different performance characteristics, as described below. <p xmlns="urn:ndoc-schema"></p> The first invocation of this filter on a given field will be slower, since a <a href="Lucene.Net.Search.StringIndex.html">StringIndex</a> must be created. Subsequent invocations using the same field will re-use this cache. However, as with all functionality based on <a href="Lucene.Net.Search.FieldCacheTermsFilter.FieldCache.html">FieldCache</a>, persistent RAM is consumed to hold the cache, and is not freed until the <a href="Lucene.Net.Index.IndexReader.html">IndexReader</a> is closed. In contrast, TermsFilter has no persistent RAM consumption. <p xmlns="urn:ndoc-schema"></p> With each search, this filter translates the specified set of Terms into a private <a href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> keyed by term number per unique <b xmlns:ndoc="urn:ndoc-schema">IndexReader</b> (normally one reader per segment). Then, during matching, the term number for each docID is retrieved from the cache and then checked for inclusion using the <b xmlns:ndoc="urn:ndoc-schema">OpenBitSet</b>. Since all testing is done using RAM resident data structures, performance should be very fast, most likely fast enough to not require further caching of the DocIdSet for each possible combination of terms. However, because docIDs are simply scanned linearly, an index with a great many small documents may find this linear scan too costly. <p xmlns="urn:ndoc-schema"></p> In contrast, TermsFilter builds up an <b xmlns:ndoc="urn:ndoc-schema">OpenBitSet</b>, keyed by docID, every time it's created, by enumerating through all matching docs using <a href="Lucene.Net.Index.TermDocs.html">TermDocs</a> to seek and scan through each term's docID list. While there is no linear scan of all docIDs, besides the allocation of the underlying array in the <b xmlns:ndoc="urn:ndoc-schema">OpenBitSet</b>, this approach requires a number of "disk seeks" in proportion to the number of terms, which can be exceptionally costly when there are cache misses in the OS's IO cache. <p xmlns="urn:ndoc-schema"></p> Generally, this filter will be slower on the first invocation for a given field, but subsequent invocations, even if you change the allowed set of Terms, should be faster than TermsFilter, especially as the number of Terms being matched increases. If you are matching only a very small number of terms, and those terms in turn match a very small number of documents, TermsFilter may perform faster. <p xmlns="urn:ndoc-schema"></p> Which filter is best is very application dependent. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldCacheTermsFilter.FieldCacheTermsFilterDocIdSet.html">FieldCacheTermsFilter.FieldCacheTermsFilterDocIdSet</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldCacheTermsFilter.FieldCacheTermsFilterDocIdSet.FieldCacheTermsFilterDocIdSetIterator.html">FieldCacheTermsFilter.FieldCacheTermsFilterDocIdSet.FieldCacheTermsFilterDocIdSetIterator</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.html">FieldComparator</a></td><td width="50%"> Expert: a FieldComparator compares hits so as to determine their sort order when collecting the top results with <a href="Lucene.Net.Search.TopFieldCollector.html">TopFieldCollector</a> . The concrete public FieldComparator classes here correspond to the SortField types. <p xmlns="urn:ndoc-schema"></p>This API is designed to achieve high performance sorting, by exposing a tight interaction with <a href="Lucene.Net.Search.FieldValueHitQueue.html">FieldValueHitQueue</a> as it visits hits. Whenever a hit is competitive, it's enrolled into a virtual slot, which is an int ranging from 0 to numHits-1. The <b xmlns:ndoc="urn:ndoc-schema">FieldComparator</b> is made aware of segment transitions during searching in case any internal state it's tracking needs to be recomputed during these transitions.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>A comparator must define these functions:<p xmlns="urn:ndoc-schema"></p><ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li><a href="Lucene.Net.Search.FieldComparator.Compare.html">Compare</a> Compare a hit at 'slot a' with hit 'slot b'.</li><li><a href="Lucene.Net.Search.FieldComparator.SetBottom.html">SetBottom</a> This method is called by <b>FieldValueHitQueue</b> to notify the FieldComparator of the current weakest ("bottom") slot. Note that this slot may not hold the weakest value according to your comparator, in cases where your comparator is not the primary one (ie, is only used to break ties from the comparators before it).</li><li><a href="Lucene.Net.Search.FieldComparator.CompareBottom.html">CompareBottom</a> Compare a new hit (docID) against the "weakest" (bottom) entry in the queue.</li><li><a href="Lucene.Net.Search.FieldComparator.Copy.html">Copy</a> Installs a new hit into the priority queue. The <b>FieldValueHitQueue</b> calls this method when a new hit is competitive.</li><li><a href="Lucene.Net.Search.FieldComparator.SetNextReader.html">SetNextReader</a> Invoked when the search is switching to the next segment. You may need to update internal state of the comparator, for example retrieving new values from the <a href="Lucene.Net.Search.FieldCache.html">FieldCache</a>.</li><li><a href="Lucene.Net.Search.FieldComparator.Item.html">Item</a> Return the sort value stored in the specified slot. This is only called at the end of the search, in order to populate <a href="Lucene.Net.Search.FieldDoc.fields.html">fields</a> when returning the top results.</li></ul><b xmlns="urn:ndoc-schema">NOTE:</b> This API is experimental and might change in incompatible ways in the next release. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.ByteComparator.html">FieldComparator.ByteComparator</a></td><td width="50%">Parses field's values as byte (using <a href="Lucene.Net.Search.FieldCache.GetBytes1.html">GetBytes</a> and sorts by ascending value </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.DocComparator.html">FieldComparator.DocComparator</a></td><td width="50%">Sorts by ascending docID </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.DoubleComparator.html">FieldComparator.DoubleComparator</a></td><td width="50%">Parses field's values as double (using <a href="Lucene.Net.Search.FieldCache.GetDoubles1.html">GetDoubles</a> and sorts by ascending value </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.FloatComparator.html">FieldComparator.FloatComparator</a></td><td width="50%">Parses field's values as float (using <a href="Lucene.Net.Search.FieldCache.GetFloats1.html">GetFloats</a> and sorts by ascending value </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.IntComparator.html">FieldComparator.IntComparator</a></td><td width="50%">Parses field's values as int (using <a href="Lucene.Net.Search.FieldCache.GetInts1.html">GetInts</a> and sorts by ascending value </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.LongComparator.html">FieldComparator.LongComparator</a></td><td width="50%">Parses field's values as long (using <a href="Lucene.Net.Search.FieldCache.GetLongs1.html">GetLongs</a> and sorts by ascending value </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.RelevanceComparator.html">FieldComparator.RelevanceComparator</a></td><td width="50%">Sorts by descending relevance. NOTE: if you are sorting only by descending relevance and then secondarily by ascending docID, peformance is faster using <a href="Lucene.Net.Search.TopScoreDocCollector.html">TopScoreDocCollector</a> directly (which <a href="Lucene.Net.Search.Searcher.Search5.html">Search</a> uses when no <a href="Lucene.Net.Search.Sort.html">Sort</a> is specified). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.ShortComparator.html">FieldComparator.ShortComparator</a></td><td width="50%">Parses field's values as short (using <a href="Lucene.Net.Search.FieldCache.GetShorts1.html">GetShorts</a>) and sorts by ascending value </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.StringComparatorLocale.html">FieldComparator.StringComparatorLocale</a></td><td width="50%">Sorts by a field's value using the Collator for a given Locale. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.StringOrdValComparator.html">FieldComparator.StringOrdValComparator</a></td><td width="50%">Sorts by field's natural String sort order, using ordinals. This is functionally equivalent to <a href="Lucene.Net.Search.FieldComparator.StringValComparator.html">FieldComparator.StringValComparator</a> , but it first resolves the string to their relative ordinal positions (using the index returned by <a href="Lucene.Net.Search.FieldCache.GetStringIndex.html">GetStringIndex</a>), and does most comparisons using the ordinals. For medium to large results, this comparator will be much faster than <b xmlns:ndoc="urn:ndoc-schema">FieldComparator.StringValComparator</b>. For very small result sets it may be slower. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparator.StringValComparator.html">FieldComparator.StringValComparator</a></td><td width="50%">Sorts by field's natural String sort order. All comparisons are done using String.compareTo, which is slow for medium to large result sets but possibly very fast for very small results sets. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldComparatorSource.html">FieldComparatorSource</a></td><td width="50%"> Provides a <a href="Lucene.Net.Search.FieldComparator.html">FieldComparator</a> for custom field sorting. <b xmlns="urn:ndoc-schema">NOTE:</b> This API is experimental and might change in incompatible ways in the next release. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldDoc.html">FieldDoc</a></td><td width="50%"> Expert: A ScoreDoc which also contains information about how to sort the referenced document. In addition to the document number and score, this object contains an array of values for the document from the field(s) used to sort. For example, if the sort criteria was to sort by fields "a", "b" then "c", the <code xmlns:ndoc="urn:ndoc-schema">fields</code> object array will have three elements, corresponding respectively to the term values for the document in fields "a", "b" and "c". The class of each element in the array will be either Integer, Float or String depending on the type of values in the terms of each field. <p xmlns="urn:ndoc-schema"></p>Created: Feb 11, 2004 1:23:38 PM </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldValueHitQueue.html">FieldValueHitQueue</a></td><td width="50%"> Expert: A hit queue for sorting by hits by terms in more than one field. Uses <code xmlns:ndoc="urn:ndoc-schema">FieldCache.DEFAULT</code> for maintaining internal term lookup tables. <b xmlns="urn:ndoc-schema">NOTE:</b> This API is experimental and might change in incompatible ways in the next release. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldValueHitQueue.Entry.html">FieldValueHitQueue.Entry</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Filter.html">Filter</a></td><td width="50%">Abstract base class for restricting which documents may be returned during searching.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FilteredDocIdSet.html">FilteredDocIdSet</a></td><td width="50%"> Abstract decorator class for a DocIdSet implementation that provides on-demand filtering/validation mechanism on a given DocIdSet. <p xmlns="urn:ndoc-schema"></p> Technically, this same functionality could be achieved with ChainedFilter (under contrib/misc), however the benefit of this class is it never materializes the full bitset for the filter. Instead, the <a href="Lucene.Net.Search.FilteredDocIdSet.Match.html">Match</a> method is invoked on-demand, per docID visited during searching. If you know few docIDs will be visited, and the logic behind <b xmlns:ndoc="urn:ndoc-schema">Match</b> is relatively costly, this may be a better way to filter than ChainedFilter. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FilteredDocIdSetIterator.html">FilteredDocIdSetIterator</a></td><td width="50%"> Abstract decorator class of a DocIdSetIterator implementation that provides on-demand filter/validation mechanism on an underlying DocIdSetIterator. See <a href="Lucene.Net.Search.FilteredDocIdSet.html">FilteredDocIdSet</a> . </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FilteredQuery.html">FilteredQuery</a></td><td width="50%"> A query that applies a filter to the results of another query. <p xmlns="urn:ndoc-schema"></p>Note: the bits are retrieved from the filter each time this query is used in a search - use a CachingWrapperFilter to avoid regenerating the bits every time. <p xmlns="urn:ndoc-schema"></p>Created: Apr 20, 2004 8:58:29 AM </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FilteredTermEnum.html">FilteredTermEnum</a></td><td width="50%">Abstract class for enumerating a subset of all terms. <p xmlns="urn:ndoc-schema"></p>Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FilterManager.html">FilterManager</a></td><td width="50%"> Filter caching singleton. It can be used to save filters locally for reuse. This class makes it possble to cache Filters even when using RMI, as it keeps the cache on the seaercher side of the RMI connection. Also could be used as a persistent storage for any filter as long as the filter provides a proper hashCode(), as that is used as the key in the cache. The cache is periodically cleaned up from a separate thread to ensure the cache doesn't exceed the maximum size. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FilterManager.FilterCleaner.html">FilterManager.FilterCleaner</a></td><td width="50%"> Keeps the cache from getting too big. If we were using Java 1.5, we could use LinkedHashMap and we would not need this thread to clean out the cache. The SortedSet sortedFilterItems is used only to sort the items from the cache, so when it's time to clean up we have the TreeSet sort the FilterItems by timestamp. Removes 1.5 * the numbers of items to make the cache smaller. For example: If cache clean size is 10, and the cache is at 15, we would remove (15 - 10) * 1.5 = 7.5 round up to 8. This way we clean the cache a bit more, and avoid having the cache cleaner having to do it frequently. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FilterManager.FilterItem.html">FilterManager.FilterItem</a></td><td width="50%"> Holds the filter and the last time the filter was used, to make LRU-based cache cleaning possible. TODO: Clean this up when we switch to Java 1.5 </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FuzzyQuery.html">FuzzyQuery</a></td><td width="50%">Implements the fuzzy search query. The similarity measurement is based on the Levenshtein (edit distance) algorithm. Warning: this query is not very scalable with its default prefix length of 0 - in this case, *every* term will be enumerated and cause an edit score calculation. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FuzzyQuery.ScoreTerm.html">FuzzyQuery.ScoreTerm</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FuzzyTermEnum.html">FuzzyTermEnum</a></td><td width="50%">Subclass of FilteredTermEnum for enumerating all terms that are similiar to the specified filter term. <p xmlns="urn:ndoc-schema"></p>Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.HitQueue.html">HitQueue</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.IndexSearcher.html">IndexSearcher</a></td><td width="50%">Implements search over a single IndexReader. <p xmlns="urn:ndoc-schema"></p>Applications usually need only call the inherited <a href="Lucene.Net.Search.Searcher.Search5.html">Search</a> or <a href="Lucene.Net.Search.Searcher.Search4.html">Search</a> methods. For performance reasons it is recommended to open only one IndexSearcher and use it for all of your searches. <a name="thread-safety" xmlns="urn:ndoc-schema"></a><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: <b xmlns:ndoc="urn:ndoc-schema">IndexSearcher</b> instances are completely thread safe, meaning multiple threads can call any of its methods, concurrently. If your application requires external synchronization, you should <b xmlns="urn:ndoc-schema">not</b> synchronize on the <code xmlns:ndoc="urn:ndoc-schema">IndexSearcher</code> instance; use your own (non-Lucene) objects instead.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.MatchAllDocsQuery.html">MatchAllDocsQuery</a></td><td width="50%"> A query that matches all documents. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.MultiPhraseQuery.html">MultiPhraseQuery</a></td><td width="50%"> MultiPhraseQuery is a generalized version of PhraseQuery, with an added method <a href="Lucene.Net.Search.MultiPhraseQuery.Add2.html">Add</a>. To use this class, to search for the phrase "Microsoft app*" first use add(Term) on the term "Microsoft", then find all terms that have "app" as prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[] terms) to add them to the query. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.MultiSearcher.html">MultiSearcher</a></td><td width="50%">Implements search over a set of <code xmlns:ndoc="urn:ndoc-schema">Searchables</code>. <p xmlns="urn:ndoc-schema"></p>Applications usually need only call the inherited <a href="Lucene.Net.Search.Searcher.Search5.html">Search</a> or <a href="Lucene.Net.Search.Searcher.Search4.html">Search</a> methods. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.MultiTermQuery.html">MultiTermQuery</a></td><td width="50%"> An abstract <a href="Lucene.Net.Search.Query.html">Query</a> that matches documents containing a subset of terms provided by a <a href="Lucene.Net.Search.FilteredTermEnum.html">FilteredTermEnum</a> enumeration. <p xmlns="urn:ndoc-schema"></p>This query cannot be used directly; you must subclass it and define <a href="Lucene.Net.Search.MultiTermQuery.GetEnum.html">GetEnum</a> to provide a <b xmlns:ndoc="urn:ndoc-schema">FilteredTermEnum</b> that iterates through the terms to be matched. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: if <a href="Lucene.Net.Search.MultiTermQuery.RewriteMethod.html">RewriteMethod</a> is either <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE.html">CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE</a> or <a href="Lucene.Net.Search.MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.html">SCORING_BOOLEAN_QUERY_REWRITE</a> , you may encounter a <a href="Lucene.Net.Search.BooleanQuery.TooManyClauses.html">BooleanQuery.TooManyClauses</a> exception during searching, which happens when the number of terms to be searched exceeds <a href="Lucene.Net.Search.BooleanQuery.MaxClauseCount.html">MaxClauseCount</a> . Setting <b xmlns:ndoc="urn:ndoc-schema">RewriteMethod</b> to <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE.html">CONSTANT_SCORE_FILTER_REWRITE</a> prevents this. <p xmlns="urn:ndoc-schema"></p>The recommended rewrite method is <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT.html">CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</a> : it doesn't spend CPU computing unhelpful scores, and it tries to pick the most performant rewrite method given the query. Note that <a href="Lucene.Net.QueryParsers.QueryParser.html">QueryParser</a> produces MultiTermQueries using <b xmlns:ndoc="urn:ndoc-schema">CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</b> by default. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.MultiTermQuery.AnonymousClassConstantScoreAutoRewrite.html">MultiTermQuery.AnonymousClassConstantScoreAutoRewrite</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.MultiTermQuery.ConstantScoreAutoRewrite.html">MultiTermQuery.ConstantScoreAutoRewrite</a></td><td width="50%">A rewrite method that tries to pick the best constant-score rewrite method based on term and document counts from the query. If both the number of terms and documents is small enough, then <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE.html">CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE</a> is used. Otherwise, <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE.html">CONSTANT_SCORE_FILTER_REWRITE</a> is used. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.MultiTermQueryWrapperFilter$1.html">MultiTermQueryWrapperFilter(T)</a></td><td width="50%"> A wrapper for <a href="Lucene.Net.Search.MultiTermQuery.html">MultiTermQuery</a>, that exposes its functionality as a <a href="Lucene.Net.Search.Filter.html">Filter</a>. <p xmlns="urn:ndoc-schema"></p><code xmlns:ndoc="urn:ndoc-schema">MultiTermQueryWrapperFilter</code> is not designed to be used by itself. Normally you subclass it to provide a Filter counterpart for a <b xmlns:ndoc="urn:ndoc-schema">MultiTermQuery</b> subclass. <p xmlns="urn:ndoc-schema"></p> For example, <a href="Lucene.Net.Search.TermRangeFilter.html">TermRangeFilter</a> and <a href="Lucene.Net.Search.PrefixFilter.html">PrefixFilter</a> extend <code xmlns:ndoc="urn:ndoc-schema">MultiTermQueryWrapperFilter</code>. This class also provides the functionality behind <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE.html">CONSTANT_SCORE_FILTER_REWRITE</a>; this is why it is not abstract. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.NumericRangeFilter.html">NumericRangeFilter</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.NumericRangeFilter$1.html">NumericRangeFilter(T)</a></td><td width="50%"> A <a href="Lucene.Net.Search.Filter.html">Filter</a> that only accepts numeric values within a specified range. To use this, you must first index the numeric values using <a href="Lucene.Net.Documents.NumericField.html">NumericField</a> (expert: <a href="Lucene.Net.Analysis.NumericTokenStream.html">NumericTokenStream</a> ). <p xmlns="urn:ndoc-schema"></p>You create a new NumericRangeFilter with the static factory methods, eg: <pre class="code" xmlns:ndoc="urn:ndoc-schema">Filter f = NumericRangeFilter.newFloatRange("weight",
            new Float(0.3f), new Float(0.10f),
            true, true);
</pre> accepts all documents whose float valued "weight" field ranges from 0.3 to 0.10, inclusive. See <a href="Lucene.Net.Search.NumericRangeQuery$1.html">NumericRangeQuery(T)</a> for details on how Lucene indexes and searches numeric valued fields. <p xmlns="urn:ndoc-schema"></p><font color="red" xmlns="urn:ndoc-schema"><b>NOTE:</b> This API is experimental and might change in incompatible ways in the next release.</font></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.NumericRangeQuery.html">NumericRangeQuery</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.NumericRangeQuery$1.html">NumericRangeQuery(T)</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>A <a href="Lucene.Net.Search.Query.html">Query</a> that matches numeric values within a specified range. To use this, you must first index the numeric values using <a href="Lucene.Net.Documents.NumericField.html">NumericField</a> (expert: <a href="Lucene.Net.Analysis.NumericTokenStream.html">NumericTokenStream</a> ). If your terms are instead textual, you should use <a href="Lucene.Net.Search.TermRangeQuery.html">TermRangeQuery</a>. <a href="Lucene.Net.Search.NumericRangeFilter$1.html">NumericRangeFilter(T)</a> is the filter equivalent of this query.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>You create a new NumericRangeQuery with the static factory methods, eg: <pre class="code" xmlns:ndoc="urn:ndoc-schema">Query q = NumericRangeQuery.newFloatRange("weight",
new Float(0.3f), new Float(0.10f),
true, true);
</pre> matches all documents whose float valued "weight" field ranges from 0.3 to 0.10, inclusive. <p xmlns="urn:ndoc-schema"></p>The performance of NumericRangeQuery is much better than the corresponding <b xmlns:ndoc="urn:ndoc-schema">TermRangeQuery</b> because the number of terms that must be searched is usually far fewer, thanks to trie indexing, described below.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>You can optionally specify a <a href="#precisionStepDesc" xmlns="urn:ndoc-schema"><code xmlns="" xmlns:ndoc="urn:ndoc-schema">precisionStep</code></a> when creating this query. This is necessary if you've changed this configuration from its default (4) during indexing. Lower values consume more disk space but speed up searching. Suitable values are between <b xmlns="urn:ndoc-schema">1</b> and <b xmlns="urn:ndoc-schema">8</b>. A good starting point to test is <b xmlns="urn:ndoc-schema">4</b>, which is the default value for all <code xmlns:ndoc="urn:ndoc-schema">Numeric*</code> classes. See <a href="#precisionStepDesc" xmlns="urn:ndoc-schema">below</a> for details. <p xmlns="urn:ndoc-schema"></p>This query defaults to <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT.html">CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</a> for 32 bit (int/float) ranges with precisionStep &lt;8 and 64 bit (long/double) ranges with precisionStep &lt;6. Otherwise it uses <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE.html">CONSTANT_SCORE_FILTER_REWRITE</a> as the number of terms is likely to be high. With precision steps of &lt;4, this query can be run with one of the BooleanQuery rewrite methods without changing BooleanQuery's default max clause count. <p xmlns="urn:ndoc-schema"></p><font color="red" xmlns="urn:ndoc-schema"><b>NOTE:</b> This API is experimental and might change in incompatible ways in the next release.</font><br xmlns:ndoc="urn:ndoc-schema" /><h3 xmlns="urn:ndoc-schema">How it works</h3><p xmlns="urn:ndoc-schema"></p>See the publication about <a target="_blank" href="http://www.panfmp.org" xmlns="urn:ndoc-schema">panFMP</a>, where this algorithm was described (referred to as <code xmlns:ndoc="urn:ndoc-schema">TrieRangeQuery</code>): <blockquote xmlns="urn:ndoc-schema"><strong>Schindler, U, Diepenbroek, M</strong>, 2008. <em>Generic XML-based Framework for Metadata Portals.</em> Computers &amp; Geosciences 34 (12), 1947-1955. <a href="http://dx.doi.org/10.1016/j.cageo.2008.02.023" target="_blank">doi:10.1016/j.cageo.2008.02.023</a></blockquote><p xmlns="urn:ndoc-schema"></p><em xmlns="urn:ndoc-schema">A quote from this paper:</em> Because Apache Lucene is a full-text search engine and not a conventional database, it cannot handle numerical ranges (e.g., field value is inside user defined bounds, even dates are numerical values). We have developed an extension to Apache Lucene that stores the numerical values in a special string-encoded format with variable precision (all numerical values like doubles, longs, floats, and ints are converted to lexicographic sortable string representations and stored with different precisions (for a more detailed description of how the values are stored, see <a href="Lucene.Net.Util.NumericUtils.html">NumericUtils</a>). A range is then divided recursively into multiple intervals for searching: The center of the range is searched only with the lowest possible precision in the <em xmlns="urn:ndoc-schema">trie</em>, while the boundaries are matched more exactly. This reduces the number of terms dramatically.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>For the variant that stores long values in 8 different precisions (each reduced by 8 bits) that uses a lowest precision of 1 byte, the index contains only a maximum of 256 distinct values in the lowest precision. Overall, a range could consist of a theoretical maximum of <code xmlns:ndoc="urn:ndoc-schema">7*255*2 + 255 = 3825</code> distinct terms (when there is a term for every distinct value of an 8-byte-number in the index and the range covers almost all of them; a maximum of 255 distinct values is used because it would always be possible to reduce the full 256 values to one term with degraded precision). In practice, we have seen up to 300 terms in most cases (index with 500,000 metadata records and a uniform value distribution).<p xmlns="urn:ndoc-schema"></p><a name="precisionStepDesc" xmlns="urn:ndoc-schema"></a><h3 xmlns="urn:ndoc-schema">Precision Step</h3><p xmlns="urn:ndoc-schema"></p>You can choose any <code xmlns:ndoc="urn:ndoc-schema">precisionStep</code> when encoding values. Lower step values mean more precisions and so more terms in index (and index gets larger). On the other hand, the maximum number of terms to match reduces, which optimized query speed. The formula to calculate the maximum term count is: <pre class="code" xmlns:ndoc="urn:ndoc-schema">n = [ (bitsPerValue/precisionStep - 1) * (2^precisionStep - 1 ) * 2 ] + (2^precisionStep - 1 )
</pre><p xmlns="urn:ndoc-schema"></p><em xmlns="urn:ndoc-schema">(this formula is only correct, when <code xmlns="" xmlns:ndoc="urn:ndoc-schema">bitsPerValue/precisionStep</code> is an integer; in other cases, the value must be rounded up and the last summand must contain the modulo of the division as precision step)</em>. For longs stored using a precision step of 4, <code xmlns:ndoc="urn:ndoc-schema">n = 15*15*2 + 15 = 465</code>, and for a precision step of 2, <code xmlns:ndoc="urn:ndoc-schema">n = 31*3*2 + 3 = 189</code>. But the faster search speed is reduced by more seeking in the term enum of the index. Because of this, the ideal <code xmlns:ndoc="urn:ndoc-schema">precisionStep</code> value can only be found out by testing. <b xmlns="urn:ndoc-schema">Important:</b> You can index with a lower precision step value and test search speed using a multiple of the original step value.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Good values for <code xmlns:ndoc="urn:ndoc-schema">precisionStep</code> are depending on usage and data type: <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li>The default for all data types is <b xmlns="urn:ndoc-schema">4</b>, which is used, when no <code>precisionStep</code> is given.</li><li>Ideal value in most cases for <em xmlns="urn:ndoc-schema">64 bit</em> data types <em xmlns="urn:ndoc-schema">(long, double)</em> is <b xmlns="urn:ndoc-schema">6</b> or <b xmlns="urn:ndoc-schema">8</b>.</li><li>Ideal value in most cases for <em xmlns="urn:ndoc-schema">32 bit</em> data types <em xmlns="urn:ndoc-schema">(int, float)</em> is <b xmlns="urn:ndoc-schema">4</b>.</li><li>Steps <b xmlns="urn:ndoc-schema">&gt;64</b> for <em xmlns="urn:ndoc-schema">long/double</em> and <b xmlns="urn:ndoc-schema">&gt;32</b> for <em xmlns="urn:ndoc-schema">int/float</em> produces one token per value in the index and querying is as slow as a conventional <b>TermRangeQuery</b>. But it can be used to produce fields, that are solely used for sorting (in this case simply use <a href="http://msdn.microsoft.com/en-us/library/System.Int32.MaxValue(VS.100).aspx">MaxValue</a> as <code>precisionStep</code>). Using <b>NumericFields</b> for sorting is ideal, because building the field cache is much faster than with text-only numbers. Sorting is also possible with range query optimized fields using one of the above <code>precisionSteps</code>.</li></ul><p xmlns="urn:ndoc-schema"></p>Comparisons of the different types of RangeQueries on an index with about 500,000 docs showed that <b xmlns:ndoc="urn:ndoc-schema">TermRangeQuery</b> in boolean rewrite mode (with raised <a href="Lucene.Net.Search.BooleanQuery.html">BooleanQuery</a> clause count) took about 30-40 secs to complete, <b xmlns:ndoc="urn:ndoc-schema">TermRangeQuery</b> in constant score filter rewrite mode took 5 secs and executing this class took &lt;100ms to complete (on an Opteron64 machine, Java 1.5, 8 bit precision step). This query type was developed for a geographic portal, where the performance for e.g. bounding boxes or exact date/time stamps is important.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.OccurExtensions.html">OccurExtensions</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ParallelMultiSearcher.html">ParallelMultiSearcher</a></td><td width="50%">Implements parallel search over a set of <code xmlns:ndoc="urn:ndoc-schema">Searchables</code>. <p xmlns="urn:ndoc-schema"></p>Applications usually need only call the inherited <a href="Lucene.Net.Search.Searcher.Search5.html">Search</a> or <a href="Lucene.Net.Search.Searcher.Search4.html">Search</a> methods. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.PhraseQuery.html">PhraseQuery</a></td><td width="50%">A Query that matches documents containing a particular sequence of terms. A PhraseQuery is built by QueryParser for input like <code xmlns:ndoc="urn:ndoc-schema">"new york"</code>. <p xmlns="urn:ndoc-schema"></p>This query may be combined with other terms or queries with a <a href="Lucene.Net.Search.BooleanQuery.html">BooleanQuery</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.PositiveScoresOnlyCollector.html">PositiveScoresOnlyCollector</a></td><td width="50%"> A <a href="Lucene.Net.Search.Collector.html">Collector</a> implementation which wraps another <b xmlns:ndoc="urn:ndoc-schema">Collector</b> and makes sure only documents with scores &gt; 0 are collected. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.PrefixFilter.html">PrefixFilter</a></td><td width="50%"> A Filter that restricts search results to values that have a matching prefix in a given field. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.PrefixQuery.html">PrefixQuery</a></td><td width="50%">A Query that matches documents containing terms with a specified prefix. A PrefixQuery is built by QueryParser for input like <code xmlns:ndoc="urn:ndoc-schema">app*</code>. <p xmlns="urn:ndoc-schema"></p>This query uses the <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT.html">CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</a> rewrite method. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.PrefixTermEnum.html">PrefixTermEnum</a></td><td width="50%"> Subclass of FilteredTermEnum for enumerating all terms that match the specified prefix filter term. <p xmlns="urn:ndoc-schema"></p> Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Query.html">Query</a></td><td width="50%">The abstract base class for queries. <p xmlns="urn:ndoc-schema"></p>Instantiable subclasses are: <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li><a href="Lucene.Net.Search.TermQuery.html">TermQuery</a></li><li><a href="Lucene.Net.Search.MultiTermQuery.html">MultiTermQuery</a></li><li><a href="Lucene.Net.Search.BooleanQuery.html">BooleanQuery</a></li><li><a href="Lucene.Net.Search.WildcardQuery.html">WildcardQuery</a></li><li><a href="Lucene.Net.Search.PhraseQuery.html">PhraseQuery</a></li><li><a href="Lucene.Net.Search.PrefixQuery.html">PrefixQuery</a></li><li><a href="Lucene.Net.Search.MultiPhraseQuery.html">MultiPhraseQuery</a></li><li><a href="Lucene.Net.Search.FuzzyQuery.html">FuzzyQuery</a></li><li><a href="Lucene.Net.Search.TermRangeQuery.html">TermRangeQuery</a></li><li><a href="Lucene.Net.Search.NumericRangeQuery$1.html">NumericRangeQuery(T)</a></li><li><a href="Lucene.Net.Search.Spans.SpanQuery.html">SpanQuery</a></li></ul><p xmlns="urn:ndoc-schema"></p>A parser for queries is contained in: <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li><a href="Lucene.Net.QueryParsers.QueryParser.html">QueryParser</a></li></ul></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.QueryTermVector.html">QueryTermVector</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.QueryWrapperFilter.html">QueryWrapperFilter</a></td><td width="50%"> Constrains search results to only match those which also match a provided query. <p xmlns="urn:ndoc-schema"></p> This could be used, for example, with a <a href="Lucene.Net.Search.TermRangeQuery.html">TermRangeQuery</a> on a suitably formatted date field to implement date filtering. One could re-use a single QueryFilter that matches, e.g., only documents modified within the last week. The QueryFilter and TermRangeQuery would only need to be reconstructed once per day. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.RewriteMethod.html">RewriteMethod</a></td><td width="50%">Abstract class that defines how the query is rewritten. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ScoreCachingWrappingScorer.html">ScoreCachingWrappingScorer</a></td><td width="50%"> A <a href="Lucene.Net.Search.Scorer.html">Scorer</a> which wraps another scorer and caches the score of the current document. Successive calls to <a href="Lucene.Net.Search.ScoreCachingWrappingScorer.Score2.html">Score</a> will return the same result and will not invoke the wrapped Scorer's score() method, unless the current document has changed.<br xmlns:ndoc="urn:ndoc-schema" /> This class might be useful due to the changes done to the <a href="Lucene.Net.Search.Collector.html">Collector</a> interface, in which the score is not computed for a document by default, only if the collector requests it. Some collectors may need to use the score in several places, however all they have in hand is a <b xmlns:ndoc="urn:ndoc-schema">Scorer</b> object, and might end up computing the score of a document more than once. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ScoreDoc.html">ScoreDoc</a></td><td width="50%">Expert: Returned by low-level search implementations.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Scorer.html">Scorer</a></td><td width="50%"> Expert: Common scoring functionality for different types of queries. <p xmlns="urn:ndoc-schema"></p> A <code xmlns:ndoc="urn:ndoc-schema">Scorer</code> iterates over documents matching a query in increasing order of doc Id. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p> Document scores are computed using a given <code xmlns:ndoc="urn:ndoc-schema">Similarity</code> implementation. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: The values Float.Nan, Float.NEGATIVE_INFINITY and Float.POSITIVE_INFINITY are not valid scores. Certain collectors (eg <a href="Lucene.Net.Search.TopScoreDocCollector.html">TopScoreDocCollector</a> ) will not properly collect hits with these scores. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Searcher.html">Searcher</a></td><td width="50%"> An abstract base class for search implementations. Implements the main search methods. <p xmlns="urn:ndoc-schema"></p> Note that you can only access hits from a Searcher as long as it is not yet closed, otherwise an IOException will be thrown. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Similarity.html">Similarity</a></td><td width="50%">Expert: Scoring API. <p xmlns="urn:ndoc-schema"></p>Subclasses implement search scoring. <p xmlns="urn:ndoc-schema"></p>The score of query <code xmlns:ndoc="urn:ndoc-schema">q</code> for document <code xmlns:ndoc="urn:ndoc-schema">d</code> correlates to the cosine-distance or dot-product between document and query vectors in a <a href="http://en.wikipedia.org/wiki/Vector_Space_Model" xmlns="urn:ndoc-schema"> Vector Space Model (VSM) of Information Retrieval</a>. A document whose vector is closer to the query vector in that model is scored higher. The score is computed as follows: <p xmlns="urn:ndoc-schema"></p><table cellpadding="1" cellspacing="0" border="1" align="center" xmlns="urn:ndoc-schema"><tr><td><table cellpadding="1" cellspacing="0" border="0" align="center"><tr><td valign="middle" align="right" rowspan="1"> score(q,d)   =   <A HREF="#formula_coord">coord(q,d)</A>  ·  <A HREF="#formula_queryNorm">queryNorm(q)</A>  ·  </td><td valign="bottom" align="center" rowspan="1"><big><big><big>∑</big></big></big></td><td valign="middle" align="right" rowspan="1"><big><big>(</big></big><A HREF="#formula_tf">tf(t in d)</A>  ·  <A HREF="#formula_idf">idf(t)</A><sup>2</sup>  ·  <A HREF="#formula_termBoost">t.Boost</A> ·  <A HREF="#formula_norm">norm(t,d)</A><big><big>)</big></big></td></tr><tr valigh="top"><td></td><td align="center"><small>t in q</small></td><td></td></tr></table></td></tr></table><p xmlns="urn:ndoc-schema"></p> where <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li><A NAME="formula_tf" xmlns="urn:ndoc-schema"></A><b xmlns="urn:ndoc-schema">tf(t in d)</b> correlates to the term's <i xmlns="urn:ndoc-schema">frequency</i>, defined as the number of times term <i xmlns="urn:ndoc-schema">t</i> appears in the currently scored document <i xmlns="urn:ndoc-schema">d</i>. Documents that have more occurrences of a given term receive a higher score. The default computation for <i xmlns="urn:ndoc-schema">tf(t in d)</i> in <a href="Lucene.Net.Search.DefaultSimilarity.Tf1.html">DefaultSimilarity</a> is: <br /> <br /><table cellpadding="2" cellspacing="2" border="0" align="center" xmlns="urn:ndoc-schema"><tr><td valign="middle" align="right" rowspan="1"><b xmlns="">tf(t in d)</b>   =   </td><td valign="top" align="center" rowspan="1"> frequency<sup><big>½</big></sup></td></tr></table><br /> <br /></li><li><A NAME="formula_idf" xmlns="urn:ndoc-schema"></A><b xmlns="urn:ndoc-schema">idf(t)</b> stands for Inverse Document Frequency. This value correlates to the inverse of <i xmlns="urn:ndoc-schema">docFreq</i> (the number of documents in which the term <i xmlns="urn:ndoc-schema">t</i> appears). This means rarer terms give higher contribution to the total score. The default computation for <i xmlns="urn:ndoc-schema">idf(t)</i> in <a href="Lucene.Net.Search.DefaultSimilarity.Idf.html">DefaultSimilarity</a> is: <br /> <br /><table cellpadding="2" cellspacing="2" border="0" align="center" xmlns="urn:ndoc-schema"><tr><td valign="middle" align="right"><b xmlns="">idf(t)</b>  =   </td><td valign="middle" align="center"> 1 + log <big>(</big></td><td valign="middle" align="center"><table><tr><td align="center"><small>numDocs</small></td></tr><tr><td align="center">–––––––––</td></tr><tr><td align="center"><small>docFreq+1</small></td></tr></table></td><td valign="middle" align="center"><big>)</big></td></tr></table><br /> <br /></li><li><A NAME="formula_coord" xmlns="urn:ndoc-schema"></A><b xmlns="urn:ndoc-schema">coord(q,d)</b> is a score factor based on how many of the query terms are found in the specified document. Typically, a document that contains more of the query's terms will receive a higher score than another document with fewer query terms. This is a search time factor computed in <a href="Lucene.Net.Search.Similarity.Coord.html">coord(q,d)</a> by the Similarity in effect at search time. <br /> <br /></li><li><b xmlns="urn:ndoc-schema"><A NAME="formula_queryNorm"></A> queryNorm(q) </b> is a normalizing factor used to make scores between queries comparable. This factor does not affect document ranking (since all ranked documents are multiplied by the same factor), but rather just attempts to make scores from different queries (or even different indexes) comparable. This is a search time factor computed by the Similarity in effect at search time. The default computation in <a href="Lucene.Net.Search.DefaultSimilarity.QueryNorm.html">DefaultSimilarity</a> is: <br /> <br /><table cellpadding="1" cellspacing="0" border="0" align="center" xmlns="urn:ndoc-schema"><tr><td valign="middle" align="right" rowspan="1"> queryNorm(q)   =   <b xmlns="">queryNorm(sumOfSquaredWeights)</b>   =   </td><td valign="middle" align="center" rowspan="1"><table><tr><td align="center"><big>1</big></td></tr><tr><td align="center"><big> –––––––––––––– </big></td></tr><tr><td align="center">sumOfSquaredWeights<sup><big>½</big></sup></td></tr></table></td></tr></table><br /> <br /> The sum of squared weights (of the query terms) is computed by the query <a href="Lucene.Net.Search.Weight.html">Weight</a> object. For example, a <a href="Lucene.Net.Search.BooleanQuery.html">boolean query</a> computes this value as: <br /> <br /><table cellpadding="1" cellspacing="0" border="0" align="center" xmlns="urn:ndoc-schema"><tr><td valign="middle" align="right" rowspan="1"><a href="Lucene.Net.Search.Weight.GetSumOfSquaredWeights.html" xmlns="">GetSumOfSquaredWeights</a>   =   <a href="Lucene.Net.Search.Query.Boost.html" xmlns="">q.Boost</a><sup><big>2</big></sup>  ·  </td><td valign="bottom" align="center" rowspan="1"><big><big><big>∑</big></big></big></td><td valign="middle" align="right" rowspan="1"><big><big>(</big></big><A HREF="#formula_idf">idf(t)</A>  ·  <A HREF="#formula_termBoost">t.Boost</A><big><big>) <sup>2</sup></big></big></td></tr><tr valigh="top"><td></td><td align="center"><small>t in q</small></td><td></td></tr></table><br /> <br /></li><li><A NAME="formula_termBoost" xmlns="urn:ndoc-schema"></A><b xmlns="urn:ndoc-schema">t.Boost</b> is a search time boost of term <i xmlns="urn:ndoc-schema">t</i> in the query <i xmlns="urn:ndoc-schema">q</i> as specified in the query text (see <A HREF="../../../../../../queryparsersyntax.html#Boosting a Term" xmlns="urn:ndoc-schema">query syntax</A>), or as set by application calls to <b>Boost</b>. Notice that there is really no direct API for accessing a boost of one term in a multi term query, but rather multi terms are represented in a query as multi <a href="Lucene.Net.Search.TermQuery.html">TermQuery</a> objects, and so the boost of a term in the query is accessible by calling the sub-query <b>Boost</b>. <br /> <br /></li><li><A NAME="formula_norm" xmlns="urn:ndoc-schema"></A><b xmlns="urn:ndoc-schema">norm(t,d)</b> encapsulates a few (indexing time) boost and length factors: <ul type="disc"><li><b xmlns="urn:ndoc-schema">Document boost</b> - set by calling <a href="Lucene.Net.Documents.Document.Boost.html">doc.Boost</a> before adding the document to the index. </li><li><b xmlns="urn:ndoc-schema">Field boost</b> - set by calling <a href="Lucene.Net.Documents.IFieldable.Boost.html">field.Boost</a> before adding the field to a document. </li><li><a href="Lucene.Net.Search.Similarity.LengthNorm.html">LengthNorm(field)</a> - computed when the document is added to the index in accordance with the number of tokens of this field in the document, so that shorter fields contribute more to the score. LengthNorm is computed by the Similarity class in effect at indexing. </li></ul><p xmlns="urn:ndoc-schema"></p> When a document is added to the index, all the above factors are multiplied. If the document has multiple fields with the same name, all their boosts are multiplied together: <br /> <br /><table cellpadding="1" cellspacing="0" border="0" align="center" xmlns="urn:ndoc-schema"><tr><td valign="middle" align="right" rowspan="1"> norm(t,d)   =   <b xmlns="">doc.Boost</b>  ·  <b xmlns="">LengthNorm(field)</b>  ·  </td><td valign="bottom" align="center" rowspan="1"><big><big><big>∏</big></big></big></td><td valign="middle" align="right" rowspan="1"><b xmlns="">field.Boost</b></td></tr><tr valigh="top"><td></td><td align="center"><small>field <i><b>f</b></i> in <i>d</i> named as <i><b>t</b></i></small></td><td></td></tr></table><br /> <br /> However the resulted <i xmlns="urn:ndoc-schema">norm</i> value is <a href="Lucene.Net.Search.Similarity.EncodeNorm.html">encoded</a> as a single byte before being stored. At search time, the norm byte value is read from the index <a href="Lucene.Net.Store.Directory.html">directory</a> and <a href="Lucene.Net.Search.Similarity.DecodeNorm.html">decoded</a> back to a float <i xmlns="urn:ndoc-schema">norm</i> value. This encoding/decoding, while reducing index size, comes with the price of precision loss - it is not guaranteed that decode(encode(x)) = x. For instance, decode(encode(0.89)) = 0.75. Also notice that search time is too late to modify this <i xmlns="urn:ndoc-schema">norm</i> part of scoring, e.g. by using a different <b>Similarity</b> for search. <br /> <br /></li></ul></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SimilarityDelegator.html">SimilarityDelegator</a></td><td width="50%">Expert: Delegating scoring implementation. Useful in <a href="Lucene.Net.Search.Query.GetSimilarity.html">GetSimilarity</a> implementations, to override only certain methods of a Searcher's Similiarty implementation.. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SingleTermEnum.html">SingleTermEnum</a></td><td width="50%"> Subclass of FilteredTermEnum for enumerating a single term. <p xmlns="urn:ndoc-schema"></p> This can be used by <a href="Lucene.Net.Search.MultiTermQuery.html">MultiTermQuery</a>s that need only visit one term, but want to preserve MultiTermQuery semantics such as <a href="Lucene.Net.Search.RewriteMethod.html">RewriteMethod</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Sort.html">Sort</a></td><td width="50%"> Encapsulates sort criteria for returned hits. <p xmlns="urn:ndoc-schema"></p>The fields used to determine sort order must be carefully chosen. Documents must contain a single term in such a field, and the value of the term should indicate the document's relative position in a given sort order. The field must be indexed, but should not be tokenized, and does not need to be stored (unless you happen to want it back with the rest of your document data). In other words: <p xmlns="urn:ndoc-schema"></p><code xmlns:ndoc="urn:ndoc-schema">document.add (new Field ("byNumber", Integer.toString(x), Field.Store.NO, Field.Index.NOT_ANALYZED));</code><p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><h3 xmlns="urn:ndoc-schema">Valid Types of Values</h3><p xmlns="urn:ndoc-schema"></p>There are four possible kinds of term values which may be put into sorting fields: Integers, Longs, Floats, or Strings. Unless <a href="Lucene.Net.Search.SortField.html">SortField</a> objects are specified, the type of value in the field is determined by parsing the first term in the field. <p xmlns="urn:ndoc-schema"></p>Integer term values should contain only digits and an optional preceding negative sign. Values must be base 10 and in the range <code xmlns:ndoc="urn:ndoc-schema">Integer.MIN_VALUE</code> and <code xmlns:ndoc="urn:ndoc-schema">Integer.MAX_VALUE</code> inclusive. Documents which should appear first in the sort should have low value integers, later documents high values (i.e. the documents should be numbered <code xmlns:ndoc="urn:ndoc-schema">1..n</code> where <code xmlns:ndoc="urn:ndoc-schema">1</code> is the first and <code xmlns:ndoc="urn:ndoc-schema">n</code> the last). <p xmlns="urn:ndoc-schema"></p>Long term values should contain only digits and an optional preceding negative sign. Values must be base 10 and in the range <code xmlns:ndoc="urn:ndoc-schema">Long.MIN_VALUE</code> and <code xmlns:ndoc="urn:ndoc-schema">Long.MAX_VALUE</code> inclusive. Documents which should appear first in the sort should have low value integers, later documents high values. <p xmlns="urn:ndoc-schema"></p>Float term values should conform to values accepted by <a href="http://msdn.microsoft.com/en-us/library/System.Single.Parse(System.String)(VS.100).aspx">Parse</a> (except that <code xmlns:ndoc="urn:ndoc-schema">NaN</code> and <code xmlns:ndoc="urn:ndoc-schema">Infinity</code> are not supported). Documents which should appear first in the sort should have low values, later documents high values. <p xmlns="urn:ndoc-schema"></p>String term values can contain any valid String, but should not be tokenized. The values are sorted according to their <a href="http://msdn.microsoft.com/en-us/library/System.IComparable(VS.100).aspx">natural order</a>. Note that using this type of term value has higher memory requirements than the other two types. <p xmlns="urn:ndoc-schema"></p><h3 xmlns="urn:ndoc-schema">Object Reuse</h3><p xmlns="urn:ndoc-schema"></p>One of these objects can be used multiple times and the sort order changed between usages. <p xmlns="urn:ndoc-schema"></p>This class is thread safe. <p xmlns="urn:ndoc-schema"></p><h3 xmlns="urn:ndoc-schema">Memory Usage</h3><p xmlns="urn:ndoc-schema"></p>Sorting uses of caches of term values maintained by the internal HitQueue(s). The cache is static and contains an integer or float array of length <code xmlns:ndoc="urn:ndoc-schema">IndexReader.MaxDoc</code> for each field name for which a sort is performed. In other words, the size of the cache in bytes is: <p xmlns="urn:ndoc-schema"></p><code xmlns:ndoc="urn:ndoc-schema">4 * IndexReader.MaxDoc * (# of different fields actually used to sort)</code><p xmlns="urn:ndoc-schema"></p>For String fields, the cache is larger: in addition to the above array, the value of every term in the field is kept in memory. If there are many unique terms in the field, this could be quite large. <p xmlns="urn:ndoc-schema"></p>Note that the size of the cache is not affected by how many fields are in the index and <i xmlns="urn:ndoc-schema">might</i> be used to sort - only by the ones actually used to sort a result set. <p xmlns="urn:ndoc-schema"></p>Created: Feb 12, 2004 10:53:57 AM </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SortField.html">SortField</a></td><td width="50%"> Stores information about how to sort documents by terms in an individual field. Fields must be indexed in order to sort by them. <p xmlns="urn:ndoc-schema"></p>Created: Feb 11, 2004 1:25:29 PM </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SpanFilter.html">SpanFilter</a></td><td width="50%">Abstract base class providing a mechanism to restrict searches to a subset of an index and also maintains and returns position information. This is useful if you want to compare the positions from a SpanQuery with the positions of items in a filter. For instance, if you had a SpanFilter that marked all the occurrences of the word "foo" in documents, and then you entered a new SpanQuery containing bar, you could not only filter by the word foo, but you could then compare position information for post processing. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SpanFilterResult.html">SpanFilterResult</a></td><td width="50%"> The results of a SpanQueryFilter. Wraps the BitSet and the position information from the SpanQuery <p xmlns="urn:ndoc-schema"></p> NOTE: This API is still experimental and subject to change. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SpanFilterResult.PositionInfo.html">SpanFilterResult.PositionInfo</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SpanFilterResult.StartEnd.html">SpanFilterResult.StartEnd</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.SpanQueryFilter.html">SpanQueryFilter</a></td><td width="50%"> Constrains search results to only match those which also match a provided query. Also provides position information about where each document matches at the cost of extra space compared with the QueryWrapperFilter. There is an added cost to this above what is stored in a <a href="Lucene.Net.Search.QueryWrapperFilter.html">QueryWrapperFilter</a>. Namely, the position information for each matching document is stored. <p xmlns="urn:ndoc-schema"></p> This filter does not cache. See the <a href="Lucene.Net.Search.CachingSpanFilter.html">CachingSpanFilter</a> for a wrapper that caches. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.StringIndex.html">StringIndex</a></td><td width="50%">Expert: Stores term text values and document ordering data. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TermQuery.html">TermQuery</a></td><td width="50%">A Query that matches documents containing a term. This may be combined with other terms with a <a href="Lucene.Net.Search.BooleanQuery.html">BooleanQuery</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TermRangeFilter.html">TermRangeFilter</a></td><td width="50%"> A Filter that restricts search results to a range of values in a given field. <p xmlns="urn:ndoc-schema"></p>This filter matches the documents looking for terms that fall into the supplied range according to <a href="http://msdn.microsoft.com/en-us/library/System.String.CompareTo(System.String)(VS.100).aspx">CompareTo</a>. It is not intended for numerical ranges, use <a href="Lucene.Net.Search.NumericRangeFilter$1.html">NumericRangeFilter(T)</a> instead. <p xmlns="urn:ndoc-schema"></p>If you construct a large number of range filters with different ranges but on the same field, <a href="Lucene.Net.Search.FieldCacheRangeFilter.html">FieldCacheRangeFilter</a> may have significantly better performance. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TermRangeQuery.html">TermRangeQuery</a></td><td width="50%"> A Query that matches documents within an exclusive range of terms. <p xmlns="urn:ndoc-schema"></p>This query matches the documents looking for terms that fall into the supplied range according to <a href="http://msdn.microsoft.com/en-us/library/System.String.CompareTo(System.String)(VS.100).aspx">CompareTo</a>. It is not intended for numerical ranges, use <a href="Lucene.Net.Search.NumericRangeQuery$1.html">NumericRangeQuery(T)</a> instead. <p xmlns="urn:ndoc-schema"></p>This query uses the <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT.html">CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</a> rewrite method. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TermRangeTermEnum.html">TermRangeTermEnum</a></td><td width="50%"> Subclass of FilteredTermEnum for enumerating all terms that match the specified range parameters. <p xmlns="urn:ndoc-schema"></p> Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TermScorer.html">TermScorer</a></td><td width="50%">Expert: A <code xmlns:ndoc="urn:ndoc-schema">Scorer</code> for documents matching a <code xmlns:ndoc="urn:ndoc-schema">Term</code>.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TimeLimitingCollector.html">TimeLimitingCollector</a></td><td width="50%"> The <b xmlns:ndoc="urn:ndoc-schema">TimeLimitingCollector</b> is used to timeout search requests that take longer than the maximum allowed search time limit. After this time is exceeded, the search thread is stopped by throwing a <a href="Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.html">TimeLimitingCollector.TimeExceededException</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.html">TimeLimitingCollector.TimeExceededException</a></td><td width="50%">Thrown when elapsed search time exceeds allowed search time. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TopDocs.html">TopDocs</a></td><td width="50%"> Represents hits returned by <a href="Lucene.Net.Search.Searcher.Search4.html">Search</a> and <a href="Lucene.Net.Search.Searcher.Search5.html">Search</a></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TopDocsCollector$1.html">TopDocsCollector(T)</a></td><td width="50%"> A base class for all collectors that return a <a href="Lucene.Net.Search.TopDocs.html">TopDocs</a> output. This collector allows easy extension by providing a single constructor which accepts a <a href="Lucene.Net.Util.PriorityQueue$1.html">PriorityQueue(T)</a> as well as protected members for that priority queue and a counter of the number of total hits.<br xmlns:ndoc="urn:ndoc-schema" /> Extending classes can override <a href="Lucene.Net.Search.TopDocsCollector$1.TopDocs3.html">TopDocs</a> and <a href="Lucene.Net.Search.TopDocsCollector$1.TotalHits.html">TotalHits</a> in order to provide their own implementation. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TopFieldCollector.html">TopFieldCollector</a></td><td width="50%"> A <a href="Lucene.Net.Search.Collector.html">Collector</a> that sorts by <a href="Lucene.Net.Search.SortField.html">SortField</a> using <a href="Lucene.Net.Search.FieldComparator.html">FieldComparator</a>s. <p xmlns="urn:ndoc-schema"></p> See the <a href="Lucene.Net.Search.TopFieldCollector.Create.html">Create</a> method for instantiating a TopFieldCollector. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> This API is experimental and might change in incompatible ways in the next release.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TopFieldDocs.html">TopFieldDocs</a></td><td width="50%"> Represents hits returned by <a href="Lucene.Net.Search.Searcher.Search1.html">Search</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.TopScoreDocCollector.html">TopScoreDocCollector</a></td><td width="50%"> A <a href="Lucene.Net.Search.Collector.html">Collector</a> implementation that collects the top-scoring hits, returning them as a <a href="Lucene.Net.Search.TopDocs.html">TopDocs</a>. This is used by <a href="Lucene.Net.Search.IndexSearcher.html">IndexSearcher</a> to implement <b xmlns:ndoc="urn:ndoc-schema">TopDocs</b>-based search. Hits are sorted by score descending and then (when the scores are tied) docID ascending. When you create an instance of this collector you should know in advance whether documents are going to be collected in doc Id order or not. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: The values <a href="http://msdn.microsoft.com/en-us/library/System.Single.NaN(VS.100).aspx">NaN</a> and <a href="http://msdn.microsoft.com/en-us/library/System.Single.NegativeInfinity(VS.100).aspx">NegativeInfinity</a> are not valid scores. This collector will not properly collect hits with such scores. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Weight.html">Weight</a></td><td width="50%"> Expert: Calculate query weights and build query scorers. <p xmlns="urn:ndoc-schema"></p> The purpose of <b xmlns:ndoc="urn:ndoc-schema">Weight</b> is to ensure searching does not modify a <a href="Lucene.Net.Search.Weight.Query.html">Query</a>, so that a <b xmlns:ndoc="urn:ndoc-schema">Query</b> instance can be reused. <br xmlns:ndoc="urn:ndoc-schema" /><a href="Lucene.Net.Search.Searcher.html">Searcher</a> dependent state of the query should reside in the <b xmlns:ndoc="urn:ndoc-schema">Weight</b>. <br xmlns:ndoc="urn:ndoc-schema" /><a href="Lucene.Net.Index.IndexReader.html">IndexReader</a> dependent state should reside in the <a href="Lucene.Net.Search.Weight.Scorer.html">Scorer</a>. <p xmlns="urn:ndoc-schema"></p> A <code xmlns:ndoc="urn:ndoc-schema">Weight</code> is used in the following way: <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li>A <code>Weight</code> is constructed by a top-level query, given a <code>Searcher</code> (<a href="Lucene.Net.Search.Query.CreateWeight.html">CreateWeight</a>).</li><li>The <a href="Lucene.Net.Search.Weight.GetSumOfSquaredWeights.html">GetSumOfSquaredWeights</a> method is called on the <code>Weight</code> to compute the query normalization factor <a href="Lucene.Net.Search.Similarity.QueryNorm.html">QueryNorm</a> of the query clauses contained in the query.</li><li>The query normalization factor is passed to <a href="Lucene.Net.Search.Weight.Normalize.html">Normalize</a>. At this point the weighting is complete.</li><li>A <code>Scorer</code> is constructed by <b>Scorer</b>.</li></ul></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.WildcardQuery.html">WildcardQuery</a></td><td width="50%">Implements the wildcard search query. Supported wildcards are <code xmlns:ndoc="urn:ndoc-schema">*</code>, which matches any character sequence (including the empty one), and <code xmlns:ndoc="urn:ndoc-schema">?</code>, which matches any single character. Note this query can be slow, as it needs to iterate over many terms. In order to prevent extremely slow WildcardQueries, a Wildcard term should not start with one of the wildcards <code xmlns:ndoc="urn:ndoc-schema">*</code> or <code xmlns:ndoc="urn:ndoc-schema">?</code>. <p xmlns="urn:ndoc-schema"></p>This query uses the <a href="Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT.html">CONSTANT_SCORE_AUTO_REWRITE_DEFAULT</a> rewrite method. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.WildcardTermEnum.html">WildcardTermEnum</a></td><td width="50%"> Subclass of FilteredTermEnum for enumerating all terms that match the specified wildcard filter term. <p xmlns="urn:ndoc-schema"></p> Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it. </td></tr></table></div><h3 class="dtH3">Interfaces</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Interface</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ByteParser.html">ByteParser</a></td><td width="50%">Interface to parse bytes from document fields.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.DoubleParser.html">DoubleParser</a></td><td width="50%">Interface to parse doubles from document fields.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldCache.html">FieldCache</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FloatParser.html">FloatParser</a></td><td width="50%">Interface to parse floats from document fields.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.IntParser.html">IntParser</a></td><td width="50%">Interface to parse ints from document fields.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.LongParser.html">LongParser</a></td><td width="50%">Interface to parse long from document fields.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Parser.html">Parser</a></td><td width="50%"> Marker interface as super-interface to all parsers. It is used to specify a custom parser to <a href="Lucene.Net.Search.SortField.~ctor3.html">SortField</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Searchable.html">Searchable</a></td><td width="50%"> The interface for search implementations. <p xmlns="urn:ndoc-schema"></p> Searchable is the abstract network protocol for searching. Implementations provide search over a single index, over multiple indices, and over indices on remote servers. <p xmlns="urn:ndoc-schema"></p> Queries, filters and sort criteria are designed to be compact so that they may be efficiently passed to a remote index, with only the top-scoring hits being returned, rather than every matching hit. <b xmlns="urn:ndoc-schema">NOTE:</b> this interface is kept public for convenience. Since it is not expected to be implemented directly, it may be changed unexpectedly between releases. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.ShortParser.html">ShortParser</a></td><td width="50%">Interface to parse shorts from document fields.</td></tr></table></div><h3 class="dtH3">Structures</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Structure</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.FieldCache_Fields.html">FieldCache_Fields</a></td><td width="50%"> </td></tr></table></div><h3 class="dtH3">Enumerations</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Enumeration</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.CachingWrapperFilter.DeletesMode.html">CachingWrapperFilter.DeletesMode</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Search.Occur.html">Occur</a></td><td width="50%"> </td></tr></table></div></div></body></html>