<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>Reopen Method</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">IndexReader.Reopen Method</h1></div></div><div id="nstext"> Refreshes an IndexReader if the index has changed since this instance was (re)opened. <p xmlns="urn:ndoc-schema"></p> Opening an IndexReader is an expensive operation. This method can be used to refresh an existing IndexReader to reduce these costs. This method tries to only load segments that have changed or were created after the IndexReader was (re)opened. <p xmlns="urn:ndoc-schema"></p> If the index has not changed since this instance was (re)opened, then this call is a NOOP and returns this instance. Otherwise, a new instance is returned. The old instance is <b xmlns="urn:ndoc-schema">not</b> closed and remains usable.<br /><p xmlns="urn:ndoc-schema"></p> If the reader is reopened, even though they share resources internally, it's safe to make changes (deletions, norms) with the new reader. All shared mutable state obeys "copy on write" semantics to ensure the changes are not seen by other readers. <p xmlns="urn:ndoc-schema"></p> You can determine whether a reader was actually reopened by comparing the old instance with the instance returned by this method: <pre class="code">IndexReader reader = ... 
...
IndexReader newReader = r.reopen();
if (newReader != reader) {
...     // reader was reopened
reader.close(); 
}
reader = newReader;
...
</pre> Be sure to synchronize that code so that other threads, if present, can never use reader after it has been closed and before it's switched to newReader. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: If this reader is a near real-time reader (obtained from <a href="Lucene.Net.Index.IndexWriter.GetReader1.html">GetReader</a>, reopen() will simply call writer.getReader() again for you, though this may change in the future. <h4 class="dtH4">Overload List</h4><p> Refreshes an IndexReader if the index has changed since this instance was (re)opened.  Opening an IndexReader is an expensive operation. This method can be used to refresh an existing IndexReader to reduce these costs. This method tries to only load segments that have changed or were created after the IndexReader was (re)opened.  If the index has not changed since this instance was (re)opened, then this call is a NOOP and returns this instance. Otherwise, a new instance is returned. The old instance is <b xmlns="urn:ndoc-schema">not</b> closed and remains usable.<br /> If the reader is reopened, even though they share resources internally, it's safe to make changes (deletions, norms) with the new reader. All shared mutable state obeys "copy on write" semantics to ensure the changes are not seen by other readers.  You can determine whether a reader was actually reopened by comparing the old instance with the instance returned by this method: <pre class="code">IndexReader reader = ... 
...
IndexReader newReader = r.reopen();
if (newReader != reader) {
...     // reader was reopened
reader.close(); 
}
reader = newReader;
...
</pre> Be sure to synchronize that code so that other threads, if present, can never use reader after it has been closed and before it's switched to newReader. <b xmlns="urn:ndoc-schema">NOTE</b>: If this reader is a near real-time reader (obtained from <a href="Lucene.Net.Index.IndexWriter.GetReader1.html">GetReader</a>, reopen() will simply call writer.getReader() again for you, though this may change in the future. </p><blockquote class="dtBlock"><a href="Lucene.Net.Index.IndexReader.Reopen1.html">public virtual IndexReader Reopen()</a></blockquote><p>Expert: reopen this reader on a specific commit point. This always returns a readOnly reader. If the specified commit point matches what this reader is already on, and this reader is already readOnly, then this same instance is returned; if it is not already readOnly, a readOnly clone is returned. </p><blockquote class="dtBlock"><a href="Lucene.Net.Index.IndexReader.Reopen3.html">public virtual IndexReader Reopen(IndexCommit)</a></blockquote><p>Just like <a href="Lucene.Net.Index.IndexReader.Reopen1.html">Reopen</a>, except you can change the readOnly of the original reader. If the index is unchanged but readOnly is different then a new reader will be returned. </p><blockquote class="dtBlock"><a href="Lucene.Net.Index.IndexReader.Reopen2.html">public virtual IndexReader Reopen(bool)</a></blockquote><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Index.IndexReader.html">IndexReader Class</a> | <a href="Lucene.Net.Index.html">Lucene.Net.Index Namespace</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>