<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>FSDirectory Class</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">FSDirectory Class</h1></div></div><div id="nstext"><a name="subclasses" xmlns="urn:ndoc-schema"></a> Base class for Directory implementations that store index files in the file system. There are currently three core subclasses: <ul type="disc"><li><a href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a> is a straightforward implementation using java.io.RandomAccessFile. However, it has poor concurrent performance (multiple threads will bottleneck) as it synchronizes when multiple threads read from the same file.</li><li><a href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> uses java.nio's FileChannel's positional io when reading to avoid synchronization when reading from the same file. Unfortunately, due to a Windows-only <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734" xmlns="urn:ndoc-schema">Sun JRE bug</a> this is a poor choice for Windows, but on all other platforms this is the preferred choice. Applications using <a href="http://msdn.microsoft.com/en-us/library/System.Threading.Thread.Interrupt(VS.100).aspx">Interrupt</a> or <code>Future#cancel(boolean)</code> (on Java 1.5) should use <b>SimpleFSDirectory</b> instead. See <b>NIOFSDirectory</b> java doc for details.  <item xmlns="urn:ndoc-schema"><a href="Lucene.Net.Store.MMapDirectory.html" xmlns="">MMapDirectory</a> uses memory-mapped IO when reading. This is a good choice if you have plenty of virtual memory relative to your index size, eg if you are running on a 64 bit JRE, or you are running on a 32 bit JRE but your index sizes are small enough to fit into the virtual memory space. Java has currently the limitation of not being able to unmap files from user code. The files are unmapped, when GC releases the byte buffers. Due to <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038"> this bug</a> in Sun's JRE, MMapDirectory's <a href="Lucene.Net.Store.IndexInput.Close.html" xmlns="">Close</a> is unable to close the underlying OS file handle. Only when GC finally collects the underlying objects, which could be quite some time later, will the file handle be closed. This will consume additional transient disk usage: on Windows, attempts to delete or overwrite the files will result in an exception; on other platforms, which typically have a "delete on last close" semantics, while such operations will succeed, the bytes are still consuming space on disk. For many applications this limitation is not a problem (e.g. if you have plenty of disk space, and you don't rely on overwriting files on Windows) but it's still an important limitation to be aware of. This class supplies a (possibly dangerous) workaround mentioned in the bug report, which may fail on non-Sun JVMs.</item> Applications using <b>Interrupt</b> or <code>Future#cancel(boolean)</code> (on Java 1.5) should use <b>SimpleFSDirectory</b> instead. See <b>MMapDirectory</b> java doc for details.</li></ul> Unfortunately, because of system peculiarities, there is no single overall best implementation. Therefore, we've added the <a href="Lucene.Net.Store.FSDirectory.Open2.html">Open</a> method, to allow Lucene to choose the best FSDirectory implementation given your environment, and the known limitations of each implementation. For users who have no reason to prefer a specific implementation, it's best to simply use <b>Open</b> . For all others, you should instantiate the desired implementation directly. <p xmlns="urn:ndoc-schema"></p>The locking implementation is by default <a href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a> , but can be changed by passing in a custom <a href="Lucene.Net.Store.LockFactory.html">LockFactory</a> instance. <p>
                For a list of all members of this type, see <a href="Lucene.Net.Store.FSDirectory~Members.html">FSDirectory Members
                </a>.
              </p><p><a href="http://msdn.microsoft.com/en-us/library/System.Object(VS.100).aspx">System.Object</a><br />   <a href="Lucene.Net.Store.Directory.html">Directory</a><br />      <b>FSDirectory</b><br />         <a href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a><br />         <a href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a><br />         <a href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a></p><div class="syntax"><div>public abstract class FSDirectory<b> : <a href="Lucene.Net.Store.Directory.html">Directory</a></b></div></div><H4 class="dtH4">Thread Safety</H4><P>
					Public static (<b>Shared</b> in Visual Basic) members of this type are
					safe for multithreaded operations. Instance members are <b>not</b> guaranteed to be
					thread-safe.
				</P><h4 class="dtH4">Requirements</h4><p><b>Namespace: </b><a href="Lucene.Net.Store.html">Lucene.Net.Store</a></p><p><b>Assembly: </b>Lucene.Net (in Lucene.Net.dll)
          </p><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Store.FSDirectory~Members.html">FSDirectory Members</a> | <a href="Lucene.Net.Store.html">Lucene.Net.Store Namespace</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>