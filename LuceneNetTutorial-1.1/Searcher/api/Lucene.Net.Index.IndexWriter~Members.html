<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>IndexWriter Members</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">IndexWriter Members
					</h1></div></div><div id="nstext"><p><a href="Lucene.Net.Index.IndexWriter.html">IndexWriter overview</a></p><h4 class="dtH4">Public Static Fields</h4><div class="tablediv"><table class="dtTABLE" cellspacing="0">
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DELETE_TERMS.html">DEFAULT_MAX_BUFFERED_DELETE_TERMS</a></td><td width="50%"> Disabled by default (because IndexWriter flushes by RAM usage by default). Change using <a href="Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms.html">SetMaxBufferedDeleteTerms</a>. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DOCS.html">DEFAULT_MAX_BUFFERED_DOCS</a></td><td width="50%"> Disabled by default (because IndexWriter flushes by RAM usage by default). Change using <a href="Lucene.Net.Index.IndexWriter.SetMaxBufferedDocs.html">SetMaxBufferedDocs</a>. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DEFAULT_MAX_FIELD_LENGTH.html">DEFAULT_MAX_FIELD_LENGTH</a></td><td width="50%"> Default value is 10,000. Change using <a href="Lucene.Net.Index.IndexWriter.SetMaxFieldLength.html">SetMaxFieldLength</a>.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DEFAULT_RAM_BUFFER_SIZE_MB.html">DEFAULT_RAM_BUFFER_SIZE_MB</a></td><td width="50%"> Default value is 16 MB (which means flush when buffered docs consume 16 MB RAM). Change using <a href="Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB.html">SetRAMBufferSizeMB</a>. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DEFAULT_TERM_INDEX_INTERVAL.html">DEFAULT_TERM_INDEX_INTERVAL</a></td><td width="50%"> Default value is 128. Change using <a href="Lucene.Net.Index.IndexWriter.TermIndexInterval.html">TermIndexInterval</a>.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DISABLE_AUTO_FLUSH.html">DISABLE_AUTO_FLUSH</a></td><td width="50%"> Value to denote a flush trigger is disabled</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH.html">MAX_TERM_LENGTH</a></td><td width="50%"> Absolute hard maximum length for a term. If a term arrives from the analyzer longer than this length, it is skipped and a message is printed to infoStream, if set (see <a href="Lucene.Net.Index.IndexWriter.SetInfoStream.html">SetInfoStream</a>). </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.WRITE_LOCK_NAME.html">WRITE_LOCK_NAME</a></td><td width="50%"> Name of the write lock in the index.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubfield.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.WRITE_LOCK_TIMEOUT.html">WRITE_LOCK_TIMEOUT</a></td><td width="50%"> Default value for the write lock timeout (1,000).</td></tr></table></div><h4 class="dtH4">Public Static Properties</h4><div class="tablediv"><table class="dtTABLE" cellspacing="0">
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DefaultInfoStream.html">DefaultInfoStream</a></td><td width="50%">Gets or sets the default info stream. If non-null, this will be the default infoStream used by a newly instantiated IndexWriter. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.DefaultWriteLockTimeout.html">DefaultWriteLockTimeout</a></td><td width="50%"> Gets or sets the default (for any instance of IndexWriter) maximum time to wait for a write lock (in milliseconds). </td></tr></table></div><h4 class="dtH4">Public Static Methods</h4><div class="tablediv"><table class="dtTABLE" cellspacing="0">
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.IsLocked.html">IsLocked</a></td><td width="50%"> Returns <code>true</code> iff the index in the named directory is currently locked. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><img src="static.gif" /><a href="Lucene.Net.Index.IndexWriter.Unlock.html">Unlock</a></td><td width="50%"> Forcibly unlocks the index in the named directory.  Caution: this should only be used by failure recovery code, when it is known that no other process nor thread is in fact currently accessing this index. </td></tr></table></div><h4 class="dtH4">Public Instance Constructors</h4><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr VALIGN="top"><td width="50%"><img src="pubmethod.gif" /><a href="Lucene.Net.Index.IndexWriter~Constructors.html">IndexWriter</a></td><td width="50%">Overloaded. Initializes a new instance of the IndexWriter class.</td></tr></table></div><h4 class="dtH4">Public Instance Properties</h4><div class="tablediv"><table class="dtTABLE" cellspacing="0">
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.Analyzer.html">Analyzer</a></td><td width="50%">Returns the analyzer used by this index. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.Directory.html">Directory</a></td><td width="50%">Returns the Directory used by this index. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.InfoStream.html">InfoStream</a></td><td width="50%"> Returns the current infoStream in use by this writer.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.MaxMergeDocs.html">MaxMergeDocs</a></td><td width="50%">Gets or sets the largest segment (measured by document count) that may be merged with other segments.  Small values (e.g., less than 10,000) are best for interactive indexing, as this limits the length of pauses while indexing to a few seconds. Larger values are best for batched indexing and speedier searches.  The default value is <a href="http://msdn.microsoft.com/en-us/library/System.Int32.MaxValue(VS.100).aspx">MaxValue</a>.  Note that this method is a convenience method: it just calls mergePolicy.getMaxMergeDocs as long as mergePolicy is an instance of <b>LogMergePolicy</b>. Otherwise an IllegalArgumentException is thrown. The default merge policy (<a href="Lucene.Net.Index.LogByteSizeMergePolicy.html">LogByteSizeMergePolicy</a>) also allows you to set this limit by net size (in MB) of the segment, using <a href="Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB.html">MaxMergeMB</a>.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.MergedSegmentWarmer.html">MergedSegmentWarmer</a></td><td width="50%">Gets or sets the merged segment warmer. See <a href="Lucene.Net.Index.IndexWriter.IndexReaderWarmer.html">IndexWriter.IndexReaderWarmer</a> . </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.MergeFactor.html">MergeFactor</a></td><td width="50%">Gets or sets the number of segments that are merged at once and also controls the total number of segments allowed to accumulate in the index. Determines how often segment indices are merged by addDocument(). With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indices that are interactively maintained. Note that this method is a convenience method: it just calls mergePolicy.setMergeFactor as long as mergePolicy is an instance of <b>LogMergePolicy</b>. Otherwise an IllegalArgumentException is thrown.This must never be less than 2. The default value is 10. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.MergePolicy.html">MergePolicy</a></td><td width="50%"> Expert: returns the current MergePolicy in use by this writer.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.MergeScheduler.html">MergeScheduler</a></td><td width="50%"> Expert: returns the current MergePolicy in use by this writer. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.ReaderTermsIndexDivisor.html">ReaderTermsIndexDivisor</a></td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.Similarity.html">Similarity</a></td><td width="50%">Expert: Return the Similarity implementation used by this IndexWriter. This defaults to the current value of <a href="Lucene.Net.Search.Similarity.Default.html">Default</a>. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.TermIndexInterval.html">TermIndexInterval</a></td><td width="50%">Expert: Gets or sets the interval between indexed terms. Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. This parameter determines the amount of computation required per query term, regardless of the number of documents that contain that term. In particular, it is the maximum number of other terms that must be scanned before a term is located and its frequency and position information may be processed. In a large index with user-entered query terms, query processing time is likely to be dominated not by term lookup but rather by the processing of frequency and positional data. In a small index or when many uncommon query terms are generated (e.g., by wildcard queries) term lookup may become a dominant cost. In particular, <code>numUniqueTerms/interval</code> terms are read into memory by an IndexReader, and, on average, <code>interval/2</code> terms must be scanned for each random term access. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.UseCompoundFile.html">UseCompoundFile</a></td><td width="50%">Gets or sets the current setting of whether newly flushed segments will use the compound file format. Note that this just returns the value previously set with setUseCompoundFile(boolean), or the default value (true). You cannot use this to query the status of previously flushed segments.Note that this method is a convenience method: it just calls mergePolicy.getUseCompoundFile as long as mergePolicy is an instance of <b>LogMergePolicy</b>. Otherwise an IllegalArgumentException is thrown.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.Verbose.html">Verbose</a></td><td width="50%">Returns true if verbosing is enabled (i.e., infoStream != null). </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubproperty.gif"></img><a href="Lucene.Net.Index.IndexWriter.WriteLockTimeout.html">WriteLockTimeout</a></td><td width="50%">Gets or sets allowed timeout when acquiring the write lock.</td></tr></table></div><h4 class="dtH4">Public Instance Methods</h4><div class="tablediv"><table class="dtTABLE" cellspacing="0">
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.AddDocument~Overloads.html">AddDocument</a></td><td width="50%">Overloaded.  Adds a document to this index. If the document contains more than <a href="Lucene.Net.Index.IndexWriter.SetMaxFieldLength.html">SetMaxFieldLength</a> terms for a given field, the remainder are discarded.  Note that if an Exception is hit (for example disk full) then the index will be consistent, but this document may not have been added. Furthermore, it's possible the index will have one segment in non-compound format even when using compound files (when a merge has partially succeeded). This method periodically flushes pending documents to the Directory (see <a href="#flush" xmlns="urn:ndoc-schema">above</a>), and also periodically triggers segment merges in the index according to the <a href="Lucene.Net.Index.IndexWriter.MergePolicy.html">MergePolicy</a> in use.Merges temporarily consume space in the directory. The amount of space required is up to 1X the size of all segments being merged, when no readers/searchers are open against the index, and up to 2X the size of all segments being merged when readers/searchers are open against the index (see <a href="Lucene.Net.Index.IndexWriter.Optimize1.html">Optimize</a> for details). The sequence of primitive merge operations performed is governed by the merge policy. Note that each term in the document can be no longer than 16383 characters, otherwise an IllegalArgumentException will be thrown.Note that it's possible to create an invalid Unicode string in java if a UTF16 surrogate pair is malformed. In this case, the invalid characters are silently replaced with the Unicode replacement character U+FFFD.<b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.AddIndexes.html">AddIndexes</a></td><td width="50%">Merges the provided indexes into this index. After this completes, the index is optimized. The provided IndexReaders are not closed.<b xmlns="urn:ndoc-schema">NOTE:</b> while this is running, any attempts to add or delete documents (with another thread) will be paused until this method completes. See <a href="Lucene.Net.Index.IndexWriter.AddIndexesNoOptimize.html">AddIndexesNoOptimize</a> for details on transactional semantics, temporary free space required in the Directory, and non-CFS segments on an Exception.<b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.AddIndexesNoOptimize.html">AddIndexesNoOptimize</a></td><td width="50%"> Merges all segments from an array of indexes into this index. This may be used to parallelize batch indexing. A large document collection can be broken into sub-collections. Each sub-collection can be indexed in parallel, on a different thread, process or machine. The complete index can then be created by merging sub-collection indexes with this method. <b xmlns="urn:ndoc-schema">NOTE:</b> the index in each Directory must not be changed (opened by a writer) while this method is running. This method does not acquire a write lock in each input Directory, so it is up to the caller to enforce this. <b xmlns="urn:ndoc-schema">NOTE:</b> while this is running, any attempts to add or delete documents (with another thread) will be paused until this method completes. This method is transactional in how Exceptions are handled: it does not commit a new segments_N file until all indexes are added. This means if an Exception occurs (for example disk full), then either no indexes will have been added or they all will have been.Note that this requires temporary free space in the Directory up to 2X the sum of all input indexes (including the starting index). If readers/searchers are open against the starting index, then temporary free space required will be higher by the size of the starting index (see <a href="Lucene.Net.Index.IndexWriter.Optimize1.html">Optimize</a> for details). Once this completes, the final size of the index will be less than the sum of all input index sizes (including the starting index). It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller. This requires this index not be among those to be added. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Close~Overloads.html">Close</a></td><td width="50%">Overloaded.  Commits all changes to an index and closes all associated files. Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a> for caveats about write caching done by some IO devices.  If an Exception is hit during close, eg due to disk full or some other reason, then both the on-disk index and the internal state of the IndexWriter instance will be consistent. However, the close will not be complete even though part of it (flushing buffered documents) may have succeeded, so the write lock will still be held. If you can correct the underlying cause (eg free up some disk space) then you can call close() again. Failing that, if you want to force the write lock to be released (dangerous, because you may then lose buffered docs in the IndexWriter instance) then you can do something like this:<pre class="code">try {
    writer.close();
} finally {
    if (IndexWriter.isLocked(directory)) {
        IndexWriter.unlock(directory);
    }
}
</pre> after which, you must be certain not to use the writer instance anymore.<b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer, again. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Commit~Overloads.html">Commit</a></td><td width="50%">Overloaded. Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary. Note that this operation calls Directory.sync on the index files. That call should not return until the file contents &amp; metadata are on stable storage. For FSDirectory, this calls the OS's fsync. But, beware: some hardware devices may in fact cache writes even during fsync, and return before the bits are actually on stable storage, to give the appearance of faster performance. If you have such a device, and it does not have a battery backup (for example) then on power loss it may still lose data. Lucene cannot guarantee consistency on such devices. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.DeleteAll.html">DeleteAll</a></td><td width="50%"> Delete all documents in the index. This method will drop all buffered documents and will remove all segments from the index. This change will not be visible until a <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a> has been called. This method can be rolled back using <a href="Lucene.Net.Index.IndexWriter.Rollback.html">Rollback</a>.NOTE: this method is much faster than using deleteDocuments( new MatchAllDocsQuery() ).NOTE: this method will forcefully abort all merges in progress. If other threads are running <a href="Lucene.Net.Index.IndexWriter.Optimize1.html">Optimize</a> or any of the addIndexes methods, they will receive <a href="Lucene.Net.Index.MergePolicy.MergeAbortedException.html">MergePolicy.MergeAbortedException</a>s. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.DeleteDocuments~Overloads.html">DeleteDocuments</a></td><td width="50%">Overloaded.  Deletes the document(s) containing <code>term</code>. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Dispose~Overloads.html">Dispose</a></td><td width="50%">Overloaded.  Commits all changes to an index and closes all associated files. Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a> for caveats about write caching done by some IO devices.  If an Exception is hit during close, eg due to disk full or some other reason, then both the on-disk index and the internal state of the IndexWriter instance will be consistent. However, the close will not be complete even though part of it (flushing buffered documents) may have succeeded, so the write lock will still be held. If you can correct the underlying cause (eg free up some disk space) then you can call close() again. Failing that, if you want to force the write lock to be released (dangerous, because you may then lose buffered docs in the IndexWriter instance) then you can do something like this:<pre class="code">try {
    writer.close();
} finally {
    if (IndexWriter.isLocked(directory)) {
        IndexWriter.unlock(directory);
    }
}
</pre> after which, you must be certain not to use the writer instance anymore.<b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer, again. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="http://msdn.microsoft.com/en-us/library/System.Object.Equals(VS.100).aspx">Equals</a> (inherited from <b>Object</b>)</td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.ExpungeDeletes~Overloads.html">ExpungeDeletes</a></td><td width="50%">Overloaded. Just like <a href="Lucene.Net.Index.IndexWriter.ExpungeDeletes2.html">ExpungeDeletes</a>, except you can specify whether the call should block until the operation completes. This is only meaningful with a <a href="Lucene.Net.Index.IndexWriter.MergeScheduler.html">MergeScheduler</a> that is able to run merges in background threads. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Flush.html">Flush</a></td><td width="50%"> Flush all in-memory buffered udpates (adds and deletes) to the Directory. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.GetDocCount.html">GetDocCount</a></td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="http://msdn.microsoft.com/en-us/library/System.Object.GetHashCode(VS.100).aspx">GetHashCode</a> (inherited from <b>Object</b>)</td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.GetMaxBufferedDeleteTerms.html">GetMaxBufferedDeleteTerms</a></td><td width="50%"> Returns the number of buffered deleted terms that will trigger a flush if enabled. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.GetMaxBufferedDocs.html">GetMaxBufferedDocs</a></td><td width="50%"> Returns the number of buffered added documents that will trigger a flush if enabled. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.GetMaxFieldLength.html">GetMaxFieldLength</a></td><td width="50%"> Returns the maximum number of terms that will be indexed for a single field in a document. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.GetRAMBufferSizeMB.html">GetRAMBufferSizeMB</a></td><td width="50%"> Returns the value set by <a href="Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB.html">SetRAMBufferSizeMB</a> if enabled.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.GetReader~Overloads.html">GetReader</a></td><td width="50%">Overloaded.  Expert: returns a readonly reader, covering all committed as well as un-committed changes to the index. This provides "near real-time" searching, in that changes made during an IndexWriter session can be quickly made available for searching without closing the writer nor calling <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a>.  Note that this is functionally equivalent to calling {#commit} and then using <a href="Lucene.Net.Index.IndexReader.Open1.html">Open</a> to open a new reader. But the turarnound time of this method should be faster since it avoids the potentially costly <b>Commit</b>.  You must close the <a href="Lucene.Net.Index.IndexReader.html">IndexReader</a> returned by this method once you are done using it.  It's <i xmlns="urn:ndoc-schema">near</i> real-time because there is no hard guarantee on how quickly you can get a new reader after making changes with IndexWriter. You'll have to experiment in your situation to determine if it's faster enough. As this is a new and experimental feature, please report back on your findings so we can learn, improve and iterate.The resulting reader suppports <a href="Lucene.Net.Index.IndexReader.Reopen1.html">Reopen</a> , but that call will simply forward back to this method (though this may change in the future).The very first time this method is called, this writer instance will make every effort to pool the readers that it opens for doing merges, applying deletes, etc. This means additional resources (RAM, file descriptors, CPU time) will be consumed.For lower latency on reopening a reader, you should call <a href="Lucene.Net.Index.IndexWriter.MergedSegmentWarmer.html">MergedSegmentWarmer</a> to call <b>MergedSegmentWarmer</b> to pre-warm a newly merged segment before it's committed to the index. This is important for minimizing index-to-search delay after a large merge. If an addIndexes* call is running in another thread, then this reader will only search those segments from the foreign index that have been successfully copied over, so far. <b xmlns="urn:ndoc-schema">NOTE</b>: Once the writer is closed, any outstanding readers may continue to be used. However, if you attempt to reopen any of those readers, you'll hit an <a href="Lucene.Net.Store.AlreadyClosedException.html">AlreadyClosedException</a>.<b xmlns="urn:ndoc-schema">NOTE:</b> This API is experimental and might change in incompatible ways in the next release.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="http://msdn.microsoft.com/en-us/library/System.Object.GetType(VS.100).aspx">GetType</a> (inherited from <b>Object</b>)</td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.HasDeletions.html">HasDeletions</a></td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.MaxDoc.html">MaxDoc</a></td><td width="50%">Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), not counting deletions. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.MaybeMerge.html">MaybeMerge</a></td><td width="50%"> Expert: asks the mergePolicy whether any merges are necessary now and if so, runs the requested merges and then iterate (test again if merges are needed) until no more merges are returned by the mergePolicy. Explicit calls to maybeMerge() are usually not necessary. The most common case is when merge policy parameters have changed. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Merge_ForNUnit.html">Merge_ForNUnit</a></td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Message.html">Message</a></td><td width="50%"> Prints a message to the infoStream (if non-null), prefixed with the identifying information for this writer and the thread that's calling it. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.NewestSegment.html">NewestSegment</a></td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.NumDeletedDocs.html">NumDeletedDocs</a></td><td width="50%"> Obtain the number of deleted docs for a pooled reader. If the reader isn't being pooled, the segmentInfo's delCount is returned. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.NumDocs.html">NumDocs</a></td><td width="50%">Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), and including deletions. <b xmlns="urn:ndoc-schema">NOTE:</b> buffered deletions are not counted. If you really need these to be counted you should call <a href="Lucene.Net.Index.IndexWriter.Commit1.html">Commit</a> first. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.NumRamDocs.html">NumRamDocs</a></td><td width="50%">Expert: Return the number of documents currently buffered in RAM. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Optimize~Overloads.html">Optimize</a></td><td width="50%">Overloaded.  Requests an "optimize" operation on an index, priming the index for the fastest available search. Traditionally this has meant merging all segments into a single segment as is done in the default merge policy, but individaul merge policies may implement optimize in different ways. It is recommended that this method be called upon completion of indexing. In environments with frequent updates, optimize is best done during low volume times, if at all. See http://www.gossamer-threads.com/lists/lucene/java-dev/47895 for more discussion. Note that optimize requires 2X the index size free space in your Directory (3X if you're using compound file format). For example, if your index size is 10 MB then you need 20 MB free for optimize to complete (30 MB if you're using compound fiel format).If some but not all readers re-open while an optimize is underway, this will cause &gt; 2X temporary space to be consumed as those new readers will then hold open the partially optimized segments at that time. It is best not to re-open readers while optimize is running.The actual temporary usage could be much less than these figures (it depends on many factors).In general, once the optimize completes, the total size of the index will be less than the size of the starting index. It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller.If an Exception is hit during optimize(), for example due to disk full, the index will not be corrupt and no documents will have been lost. However, it may have been partially optimized (some segments were merged but not all), and it's possible that one of the segments in the index will be in non-compound format even when using compound file format. This will occur when the Exception is hit during conversion of the segment into compound format.This call will optimize those segments present in the index when the call started. If other threads are still adding documents and flushing segments, those newly created segments will not be optimized unless you call optimize again.<b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.PrepareCommit.html">PrepareCommit</a></td><td width="50%">Expert: prepare for commit. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.RamSizeInBytes.html">RamSizeInBytes</a></td><td width="50%">Expert: Return the total size of all index files currently cached in memory. Useful for size management with flushRamDocs() </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Rollback.html">Rollback</a></td><td width="50%"> Close the <code>IndexWriter</code> without committing any changes that have occurred since the last commit (or since it was opened, if commit hasn't been called). This removes any temporary files that had been created, after which the state of the index will be the same as it was when commit() was last called or when this writer was first opened. This also clears a previous call to <a href="Lucene.Net.Index.IndexWriter.PrepareCommit.html">PrepareCommit</a>. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SegString.html">SegString</a></td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetInfoStream.html">SetInfoStream</a></td><td width="50%">If non-null, information about merges, deletes and a message when maxFieldLength is reached will be printed to this. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms.html">SetMaxBufferedDeleteTerms</a></td><td width="50%">Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.Disabled by default (writer flushes by RAM usage). is enabled but smaller than 1 </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetMaxBufferedDocs.html">SetMaxBufferedDocs</a></td><td width="50%">Determines the minimal number of documents required before the buffered in-memory documents are flushed as a new Segment. Large values generally gives faster indexing. When this is set, the writer will flush every maxBufferedDocs added documents. Pass in <a href="Lucene.Net.Index.IndexWriter.DISABLE_AUTO_FLUSH.html">DISABLE_AUTO_FLUSH</a> to prevent triggering a flush due to number of buffered documents. Note that if flushing by RAM usage is also enabled, then the flush will be triggered by whichever comes first.Disabled by default (writer flushes by RAM usage). enabled but smaller than 2, or it disables maxBufferedDocs when ramBufferSize is already disabled </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetMaxFieldLength.html">SetMaxFieldLength</a></td><td width="50%"> The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.<strong xmlns="urn:ndoc-schema">Note:</strong> this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError. By default, no more than <a href="Lucene.Net.Index.IndexWriter.DEFAULT_MAX_FIELD_LENGTH.html">DEFAULT_MAX_FIELD_LENGTH</a> terms will be indexed for a field. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetMergePolicy.html">SetMergePolicy</a></td><td width="50%"> Expert: set the merge policy used by this writer.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetMergeScheduler.html">SetMergeScheduler</a></td><td width="50%"> Expert: set the merge scheduler used by this writer.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB.html">SetRAMBufferSizeMB</a></td><td width="50%">Determines the amount of RAM that may be used for buffering added documents and deletions before they are flushed to the Directory. Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can. When this is set, the writer will flush whenever buffered documents and deletions use this much RAM. Pass in <a href="Lucene.Net.Index.IndexWriter.DISABLE_AUTO_FLUSH.html">DISABLE_AUTO_FLUSH</a> to prevent triggering a flush due to RAM usage. Note that if flushing by document count is also enabled, then the flush will be triggered by whichever comes first.<b xmlns="urn:ndoc-schema">NOTE</b>: the account of RAM usage for pending deletions is only approximate. Specifically, if you delete by Query, Lucene currently has no way to measure the RAM usage if individual Queries so the accounting will under-estimate and you should compensate by either calling commit() periodically yourself, or by using <a href="Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms.html">SetMaxBufferedDeleteTerms</a> to flush by count instead of RAM usage (each buffered delete Query counts as one). <b xmlns="urn:ndoc-schema">NOTE</b>: because IndexWriter uses <code>int</code>s when managing its internal storage, the absolute maximum value for this setting is somewhat less than 2048 MB. The precise limit depends on various factors, such as how large your documents are, how many fields have norms, etc., so it's best to set this value comfortably under 2048.  The default value is <a href="Lucene.Net.Index.IndexWriter.DEFAULT_RAM_BUFFER_SIZE_MB.html">DEFAULT_RAM_BUFFER_SIZE_MB</a>. enabled but non-positive, or it disables ramBufferSize when maxBufferedDocs is already disabled </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.SetSimilarity.html">SetSimilarity</a></td><td width="50%">Expert: Set the Similarity implementation used by this IndexWriter. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.TestPoint.html">TestPoint</a></td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="http://msdn.microsoft.com/en-us/library/System.Object.ToString(VS.100).aspx">ToString</a> (inherited from <b>Object</b>)</td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.UpdateDocument~Overloads.html">UpdateDocument</a></td><td width="50%">Overloaded.  Updates a document by first deleting the document(s) containing <code>term</code> and then adding the new document. The delete and then add are atomic as seen by a reader on the same index (flush may happen only after the add). <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</td></tr>
<tr VALIGN="top"><td width="50%"><img src="pubmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.WaitForMerges.html">WaitForMerges</a></td><td width="50%"> Wait for any currently outstanding merges to finish. It is guaranteed that any merges started prior to calling this method will have completed once this method completes.</td></tr></table></div><h4 class="dtH4">Protected Instance Methods</h4><div class="tablediv"><table class="dtTABLE" cellspacing="0">
<tr VALIGN="top"><td width="50%"><img src="protmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.Dispose3.html">Dispose</a></td><td width="50%">Overloaded. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="protmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.DoAfterFlush.html">DoAfterFlush</a></td><td width="50%"> A hook for extending classes to execute operations after pending added and deleted documents have been flushed to the Directory but before the change is committed (new segments_N file written). </td></tr>
<tr VALIGN="top"><td width="50%"><img src="protmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.DoBeforeFlush.html">DoBeforeFlush</a></td><td width="50%"> A hook for extending classes to execute operations before pending added and deleted documents are flushed to the Directory. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="protmethod.gif"></img><a href="Lucene.Net.Index.IndexWriter.EnsureOpen~Overloads.html">EnsureOpen</a></td><td width="50%">Overloaded.  Used internally to throw an <a href="Lucene.Net.Store.AlreadyClosedException.html">AlreadyClosedException</a> if this IndexWriter has been closed. </td></tr>
<tr VALIGN="top"><td width="50%"><img src="protmethod.gif"></img><a href="http://msdn.microsoft.com/en-us/library/System.Object.Finalize(VS.100).aspx">Finalize</a> (inherited from <b>Object</b>)</td><td width="50%"></td></tr>
<tr VALIGN="top"><td width="50%"><img src="protmethod.gif"></img><a href="http://msdn.microsoft.com/en-us/library/System.Object.MemberwiseClone(VS.100).aspx">MemberwiseClone</a> (inherited from <b>Object</b>)</td><td width="50%"></td></tr></table></div><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Index.IndexWriter.html">IndexWriter Class</a> | <a href="Lucene.Net.Index.html">Lucene.Net.Index Namespace</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>