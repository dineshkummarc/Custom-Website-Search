<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>Optimize Method</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">IndexWriter.Optimize Method</h1></div></div><div id="nstext"> Requests an "optimize" operation on an index, priming the index for the fastest available search. Traditionally this has meant merging all segments into a single segment as is done in the default merge policy, but individaul merge policies may implement optimize in different ways. <p xmlns="urn:ndoc-schema"></p>It is recommended that this method be called upon completion of indexing. In environments with frequent updates, optimize is best done during low volume times, if at all. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>See http://www.gossamer-threads.com/lists/lucene/java-dev/47895 for more discussion. <p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Note that optimize requires 2X the index size free space in your Directory (3X if you're using compound file format). For example, if your index size is 10 MB then you need 20 MB free for optimize to complete (30 MB if you're using compound fiel format).<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>If some but not all readers re-open while an optimize is underway, this will cause &gt; 2X temporary space to be consumed as those new readers will then hold open the partially optimized segments at that time. It is best not to re-open readers while optimize is running.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>The actual temporary usage could be much less than these figures (it depends on many factors).<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>In general, once the optimize completes, the total size of the index will be less than the size of the starting index. It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>If an Exception is hit during optimize(), for example due to disk full, the index will not be corrupt and no documents will have been lost. However, it may have been partially optimized (some segments were merged but not all), and it's possible that one of the segments in the index will be in non-compound format even when using compound file format. This will occur when the Exception is hit during conversion of the segment into compound format.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>This call will optimize those segments present in the index when the call started. If other threads are still adding documents and flushing segments, those newly created segments will not be optimized unless you call optimize again.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.<p xmlns="urn:ndoc-schema"></p><h4 class="dtH4">Overload List</h4><p> Requests an "optimize" operation on an index, priming the index for the fastest available search. Traditionally this has meant merging all segments into a single segment as is done in the default merge policy, but individaul merge policies may implement optimize in different ways. It is recommended that this method be called upon completion of indexing. In environments with frequent updates, optimize is best done during low volume times, if at all. See http://www.gossamer-threads.com/lists/lucene/java-dev/47895 for more discussion. Note that optimize requires 2X the index size free space in your Directory (3X if you're using compound file format). For example, if your index size is 10 MB then you need 20 MB free for optimize to complete (30 MB if you're using compound fiel format).If some but not all readers re-open while an optimize is underway, this will cause &gt; 2X temporary space to be consumed as those new readers will then hold open the partially optimized segments at that time. It is best not to re-open readers while optimize is running.The actual temporary usage could be much less than these figures (it depends on many factors).In general, once the optimize completes, the total size of the index will be less than the size of the starting index. It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller.If an Exception is hit during optimize(), for example due to disk full, the index will not be corrupt and no documents will have been lost. However, it may have been partially optimized (some segments were merged but not all), and it's possible that one of the segments in the index will be in non-compound format even when using compound file format. This will occur when the Exception is hit during conversion of the segment into compound format.This call will optimize those segments present in the index when the call started. If other threads are still adding documents and flushing segments, those newly created segments will not be optimized unless you call optimize again.<b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</p><blockquote class="dtBlock"><a href="Lucene.Net.Index.IndexWriter.Optimize1.html">public virtual void Optimize()</a></blockquote><p>Just like <a href="Lucene.Net.Index.IndexWriter.Optimize1.html">Optimize</a>, except you can specify whether the call should block until the optimize completes. This is only meaningful with a <a href="Lucene.Net.Index.IndexWriter.MergeScheduler.html">MergeScheduler</a> that is able to run merges in background threads. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</p><blockquote class="dtBlock"><a href="Lucene.Net.Index.IndexWriter.Optimize3.html">public virtual void Optimize(bool)</a></blockquote><p> Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as <a href="Lucene.Net.Index.IndexWriter.Optimize1.html">Optimize</a> . <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</p><blockquote class="dtBlock"><a href="Lucene.Net.Index.IndexWriter.Optimize2.html">public virtual void Optimize(int)</a></blockquote><p>Just like <a href="Lucene.Net.Index.IndexWriter.Optimize2.html">Optimize</a>, except you can specify whether the call should block until the optimize completes. This is only meaningful with a <a href="Lucene.Net.Index.IndexWriter.MergeScheduler.html">MergeScheduler</a> that is able to run merges in background threads. <b xmlns="urn:ndoc-schema">NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="#OOME" xmlns="urn:ndoc-schema">above</a> for details.</p><blockquote class="dtBlock"><a href="Lucene.Net.Index.IndexWriter.Optimize4.html">public virtual void Optimize(int,bool)</a></blockquote><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Index.IndexWriter.html">IndexWriter Class</a> | <a href="Lucene.Net.Index.html">Lucene.Net.Index Namespace</a> | <a href="Lucene.Net.Index.LogMergePolicy.FindMergesForOptimize.html">FindMergesForOptimize</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>