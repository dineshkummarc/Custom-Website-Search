<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>DocumentsWriter Class</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">DocumentsWriter Class</h1></div></div><div id="nstext"><p> This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments. Each added document is passed to the <b>DocConsumer</b>, which in turn processes the document and interacts with other consumers in the indexing chain. Certain consumers, like <b>StoredFieldsWriter</b> and <b>TermVectorsTermsWriter</b> , digest a document and immediately write bytes to the "doc store" files (ie, they do not consume RAM per document, except while they are processing the document). Other consumers, eg <b>FreqProxTermsWriter</b> and <b>NormsWriter</b>, buffer bytes in RAM and flush only when a new segment is produced. Once we have used our allowed RAM buffer, or the number of added docs is large enough (in the case we are flushing by doc count instead of RAM usage), we create a real segment and flush it to the Directory. Threads: Multiple threads are allowed into addDocument at once. There is an initial synchronized call to getThreadState which allocates a ThreadState for this thread. The same thread will get the same ThreadState over time (thread affinity) so that if there are consistent patterns (for example each thread is indexing a different content source) then we make better use of RAM. Then processDocument is called on that ThreadState without synchronization (most of the "heavy lifting" is in this call). Finally the synchronized "finishDocument" is called to flush changes to the directory. When flush is called by IndexWriter we forcefully idle all threads and flush only once they are all idle. This means you can call flush with a given thread even while other threads are actively adding/deleting documents. Exceptions: Because this class directly updates in-memory posting lists, and flushes stored fields and term vectors directly to files in the directory, there are certain limited times when an exception can corrupt this state. For example, a disk full while flushing stored fields leaves this file in a corrupt state. Or, an OOM exception while appending to the in-memory posting lists can corrupt that posting list. We call such exceptions "aborting exceptions". In these cases we must call abort() to discard all docs added since the last flush. All other exceptions ("non-aborting exceptions") can still partially update the index structures. These updates are consistent, but, they represent only a part of the document seen up until the exception was hit. When this happens, we immediately mark the document as deleted so that the document is always atomically ("all or none") added to the index. </p><p>
                For a list of all members of this type, see <a href="Lucene.Net.Index.DocumentsWriter~Members.html">DocumentsWriter Members
                </a>.
              </p><p><a href="http://msdn.microsoft.com/en-us/library/System.Object(VS.100).aspx">System.Object</a><br />   <b>DocumentsWriter</b></p><div class="syntax"><div>public sealed class DocumentsWriter<b> : <a href="">IDisposable</a></b></div></div><H4 class="dtH4">Thread Safety</H4><P>
					Public static (<b>Shared</b> in Visual Basic) members of this type are
					safe for multithreaded operations. Instance members are <b>not</b> guaranteed to be
					thread-safe.
				</P><h4 class="dtH4">Requirements</h4><p><b>Namespace: </b><a href="Lucene.Net.Index.html">Lucene.Net.Index</a></p><p><b>Assembly: </b>Lucene.Net (in Lucene.Net.dll)
          </p><h4 class="dtH4">See Also</h4><p><a href="Lucene.Net.Index.DocumentsWriter~Members.html">DocumentsWriter Members</a> | <a href="Lucene.Net.Index.html">Lucene.Net.Index Namespace</a></p><hr /><div id="footer"><p></p><p>Version: 3.0.3.0</p></div></div></body></html>