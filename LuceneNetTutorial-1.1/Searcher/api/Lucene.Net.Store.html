<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html dir="LTR"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta content="history" name="save" /><meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" /><title>Lucene.Net.Store</title><xml></xml><link rel="stylesheet" type="text/css" href="MSDN.css" /></head><body id="bodyID" class="dtBODY"><script type="text/javascript">
    	window.onload = function() {
	    	var i = window.frames["iframe_navi"];
	    	i.syncTree(document.URL);
    	}
    </script><div id="navi"><iframe src="contents.html" id="iframe_navi" name="iframe_navi"></iframe></div><div id="nsbanner"><div id="bannerrow1"><table class="bannerparthead" cellspacing="0"><tr id="hdr"><td class="runninghead">Lucene.Net</td><td class="product"></td></tr></table></div><div id="TitleRow"><h1 class="dtH1">Lucene.Net.Store Namespace</h1></div></div><div id="nstext"><p><a href="Lucene.Net.Store~Hierarchy.html">Namespace Hierarchy</a></p><h3 class="dtH3">Classes</h3><div class="tablediv"><table class="dtTABLE" cellspacing="0"><tr valign="top"><th width="50%">Class</th><th width="50%">Description</th></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.AlreadyClosedException.html">AlreadyClosedException</a></td><td width="50%"> This exception is thrown when there is an attempt to access something that has already been closed. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.BufferedIndexInput.html">BufferedIndexInput</a></td><td width="50%">Base implementation class for buffered <a href="Lucene.Net.Store.IndexInput.html">IndexInput</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.BufferedIndexOutput.html">BufferedIndexOutput</a></td><td width="50%">Base implementation class for buffered <a href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.Directory.html">Directory</a></td><td width="50%">A Directory is a flat list of files. Files may be written once, when they are created. Once a file is created it may only be opened for read, or deleted. Random access is permitted both when reading and writing. <p xmlns="urn:ndoc-schema"></p> Java's i/o APIs not used directly, but rather all i/o is through this API. This permits things such as: <list xmlns="urn:ndoc-schema"><item> implementation of RAM-based indices;</item><item> implementation indices stored in a database, via JDBC;</item><item> implementation of an index as a single file;</item></list> Directory locking is implemented by an instance of <a href="Lucene.Net.Store.Directory.LockFactory.html">LockFactory</a> , and can be changed for each Directory instance using <a href="Lucene.Net.Store.Directory.SetLockFactory.html">SetLockFactory</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.FileSwitchDirectory.html">FileSwitchDirectory</a></td><td width="50%"> Expert: A Directory instance that switches files between two other Directory instances. <p xmlns="urn:ndoc-schema"></p>Files with the specified extensions are placed in the primary directory; others are placed in the secondary directory. The provided Set must not change once passed to this class, and must allow multiple threads to call contains at once.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: this API is new and experimental and is subject to suddenly change in the next release. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a></td><td width="50%"><a name="subclasses" xmlns="urn:ndoc-schema"></a> Base class for Directory implementations that store index files in the file system. There are currently three core subclasses: <ul type="disc" xmlns:ndoc="urn:ndoc-schema"><li><a href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a> is a straightforward implementation using java.io.RandomAccessFile. However, it has poor concurrent performance (multiple threads will bottleneck) as it synchronizes when multiple threads read from the same file.</li><li><a href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> uses java.nio's FileChannel's positional io when reading to avoid synchronization when reading from the same file. Unfortunately, due to a Windows-only <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734" xmlns="urn:ndoc-schema">Sun JRE bug</a> this is a poor choice for Windows, but on all other platforms this is the preferred choice. Applications using <a href="http://msdn.microsoft.com/en-us/library/System.Threading.Thread.Interrupt(VS.100).aspx">Interrupt</a> or <code>Future#cancel(boolean)</code> (on Java 1.5) should use <b>SimpleFSDirectory</b> instead. See <b>NIOFSDirectory</b> java doc for details.  <item xmlns="urn:ndoc-schema"><a href="Lucene.Net.Store.MMapDirectory.html" xmlns="">MMapDirectory</a> uses memory-mapped IO when reading. This is a good choice if you have plenty of virtual memory relative to your index size, eg if you are running on a 64 bit JRE, or you are running on a 32 bit JRE but your index sizes are small enough to fit into the virtual memory space. Java has currently the limitation of not being able to unmap files from user code. The files are unmapped, when GC releases the byte buffers. Due to <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038"> this bug</a> in Sun's JRE, MMapDirectory's <a href="Lucene.Net.Store.IndexInput.Close.html" xmlns="">Close</a> is unable to close the underlying OS file handle. Only when GC finally collects the underlying objects, which could be quite some time later, will the file handle be closed. This will consume additional transient disk usage: on Windows, attempts to delete or overwrite the files will result in an exception; on other platforms, which typically have a "delete on last close" semantics, while such operations will succeed, the bytes are still consuming space on disk. For many applications this limitation is not a problem (e.g. if you have plenty of disk space, and you don't rely on overwriting files on Windows) but it's still an important limitation to be aware of. This class supplies a (possibly dangerous) workaround mentioned in the bug report, which may fail on non-Sun JVMs.</item> Applications using <b>Interrupt</b> or <code>Future#cancel(boolean)</code> (on Java 1.5) should use <b>SimpleFSDirectory</b> instead. See <b>MMapDirectory</b> java doc for details.</li></ul> Unfortunately, because of system peculiarities, there is no single overall best implementation. Therefore, we've added the <a href="Lucene.Net.Store.FSDirectory.Open2.html">Open</a> method, to allow Lucene to choose the best FSDirectory implementation given your environment, and the known limitations of each implementation. For users who have no reason to prefer a specific implementation, it's best to simply use <b xmlns:ndoc="urn:ndoc-schema">Open</b> . For all others, you should instantiate the desired implementation directly. <p xmlns="urn:ndoc-schema"></p>The locking implementation is by default <a href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a> , but can be changed by passing in a custom <a href="Lucene.Net.Store.LockFactory.html">LockFactory</a> instance. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.FSLockFactory.html">FSLockFactory</a></td><td width="50%"> Base class for file system based locking implementation.</td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.ChecksumIndexInput.html">ChecksumIndexInput</a></td><td width="50%">Writes bytes through to a primary IndexOutput, computing checksum as it goes. Note that you cannot use seek(). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.ChecksumIndexOutput.html">ChecksumIndexOutput</a></td><td width="50%">Writes bytes through to a primary IndexOutput, computing checksum. Note that you cannot use seek(). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.IndexInput.html">IndexInput</a></td><td width="50%">Abstract base class for input from a file in a <a href="Lucene.Net.Store.Directory.html">Directory</a>. A random-access input stream. Used for all Lucene index input operations. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a></td><td width="50%">Abstract base class for output to a file in a Directory. A random-access output stream. Used for all Lucene index output operations. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.Lock.html">Lock</a></td><td width="50%">An interprocess mutex lock. <p xmlns="urn:ndoc-schema"></p>Typical use might look like:<pre class="code" xmlns:ndoc="urn:ndoc-schema">new Lock.With(directory.makeLock("my.lock")) {
public Object doBody() {
<i xmlns="urn:ndoc-schema">... code to execute while locked ...</i>
}
}.run();
</pre></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.Lock.With.html">Lock.With</a></td><td width="50%">Utility class for executing code with exclusive access. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.LockFactory.html">LockFactory</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Base class for Locking implementation. <a href="Lucene.Net.Store.Directory.html">Directory</a> uses instances of this class to implement locking.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Note that there are some useful tools to verify that your LockFactory is working correctly: <a href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a> , <a href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>, <a href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> .<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.LockObtainFailedException.html">LockObtainFailedException</a></td><td width="50%"> This exception is thrown when the <code xmlns:ndoc="urn:ndoc-schema">write.lock</code> could not be acquired. This happens when a writer tries to open an index that another writer already has open. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.LockReleaseFailedException.html">LockReleaseFailedException</a></td><td width="50%"> This exception is thrown when the <code xmlns:ndoc="urn:ndoc-schema">write.lock</code> could not be released. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a></td><td width="50%"> Simple standalone tool that forever acquires &amp; releases a lock using a specific LockFactory. Run without any args to see usage. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a></td><td width="50%"> Simple standalone server that must be running when you use <a href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>. This server simply verifies at most one process holds the lock at a time. Run without any args to see usage. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a></td><td width="50%">File-based <a href="Lucene.Net.Store.Directory.html">Directory</a> implementation that uses mmap for reading, and <a href="Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexOutput.html">SimpleFSDirectory.SimpleFSIndexOutput</a> for writing. <p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE</b>: memory mapping uses up a portion of the virtual memory address space in your process equal to the size of the file being mapped. Before using this class, be sure your have plenty of virtual address space, e.g. by using a 64 bit JRE, or a 32 bit JRE with indexes that are guaranteed to fit within the address space. On 32 bit platforms also consult <a href="Lucene.Net.Store.MMapDirectory.MaxChunkSize.html">MaxChunkSize</a> if you have problems with mmap failing because of fragmented address space. If you get an OutOfMemoryException, it is recommened to reduce the chunk size, until it works. <p xmlns="urn:ndoc-schema"></p>Due to <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038" xmlns="urn:ndoc-schema"> this bug</a> in Sun's JRE, MMapDirectory's <a href="Lucene.Net.Store.IndexInput.Close.html">Close</a> is unable to close the underlying OS file handle. Only when GC finally collects the underlying objects, which could be quite some time later, will the file handle be closed. <p xmlns="urn:ndoc-schema"></p>This will consume additional transient disk usage: on Windows, attempts to delete or overwrite the files will result in an exception; on other platforms, which typically have a "delete on last close" semantics, while such operations will succeed, the bytes are still consuming space on disk. For many applications this limitation is not a problem (e.g. if you have plenty of disk space, and you don't rely on overwriting files on Windows) but it's still an important limitation to be aware of. <p xmlns="urn:ndoc-schema"></p>This class supplies the workaround mentioned in the bug report (disabled by default, see <a href="Lucene.Net.Store.MMapDirectory.UseUnmap.html">UseUnmap</a>), which may fail on non-Sun JVMs. It forcefully unmaps the buffer on close by using an undocumented internal cleanup functionality. <a href="Lucene.Net.Store.MMapDirectory.UNMAP_SUPPORTED.html">UNMAP_SUPPORTED</a> is <code xmlns:ndoc="urn:ndoc-schema">true</code>, if the workaround can be enabled (with no guarantees). </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.MMapDirectory.MultiMMapIndexInput.html">MMapDirectory.MultiMMapIndexInput</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Implements <a href="Lucene.Net.Store.LockFactory.html">LockFactory</a> using native OS file locks. Note that because this LockFactory relies on java.nio.* APIs for locking, any problems with those APIs will cause locking to fail. Specifically, on certain NFS environments the java.nio.* locks will fail (the lock can incorrectly be double acquired) whereas <a href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a> worked perfectly in those same environments. For NFS based access to an index, it's recommended that you try <b xmlns:ndoc="urn:ndoc-schema">SimpleFSLockFactory</b> first and work around the one limitation that a lock file could be left when the JVM exits abnormally.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>The primary benefit of <b xmlns:ndoc="urn:ndoc-schema">NativeFSLockFactory</b> is that lock files will be properly removed (by the OS) if the JVM has an abnormal exit.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>Note that, unlike <b xmlns:ndoc="urn:ndoc-schema">SimpleFSLockFactory</b>, the existence of leftover lock files in the filesystem on exiting the JVM is fine because the OS will free the locks held against these files even though the files still remain.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>If you suspect that this or any other LockFactory is not working properly in your environment, you can easily test it by using <a href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>, <a href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a></td><td width="50%"> Not implemented. Waiting for volunteers. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.html">NIOFSDirectory.NIOFSIndexInput</a></td><td width="50%"> Not implemented. Waiting for volunteers. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.NoLockFactory.html">NoLockFactory</a></td><td width="50%"> Use this <a href="Lucene.Net.Store.LockFactory.html">LockFactory</a> to disable locking entirely. Only one instance of this lock is created. You should call <a href="Lucene.Net.Store.NoLockFactory.Instance.html">Instance</a> to get the instance. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.NoSuchDirectoryException.html">NoSuchDirectoryException</a></td><td width="50%"> This exception is thrown when you try to list a non-existent directory. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.RAMDirectory.html">RAMDirectory</a></td><td width="50%"> A memory-resident <a href="Lucene.Net.Store.Directory.html">Directory</a> implementation. Locking implementation is by default the <a href="Lucene.Net.Store.SingleInstanceLockFactory.html">SingleInstanceLockFactory</a> but can be changed with <a href="Lucene.Net.Store.Directory.SetLockFactory.html">SetLockFactory</a>. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.RAMFile.html">RAMFile</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.RAMInputStream.html">RAMInputStream</a></td><td width="50%"> A memory-resident <a href="Lucene.Net.Store.IndexInput.html">IndexInput</a> implementation. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.RAMOutputStream.html">RAMOutputStream</a></td><td width="50%"> A memory-resident <a href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a> implementation. <p xmlns:ndoc="urn:ndoc-schema">For lucene internal use.</p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a></td><td width="50%">A straightforward implementation of <a href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> using java.io.RandomAccessFile. However, this class has poor concurrent performance (multiple threads will bottleneck) as it synchronizes when multiple threads read from the same file. It's usually better to use <a href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> or <a href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a> instead. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.html">SimpleFSDirectory.SimpleFSIndexInput</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.Descriptor.html">SimpleFSDirectory.SimpleFSIndexInput.Descriptor</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexOutput.html">SimpleFSDirectory.SimpleFSIndexOutput</a></td><td width="50%"> </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a></td><td width="50%"><p xmlns="urn:ndoc-schema"></p>Implements <a href="Lucene.Net.Store.LockFactory.html">LockFactory</a> using <a href="http://msdn.microsoft.com/en-us/library/System.IO.FileInfo.Create(VS.100).aspx">Create</a> .<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p><b xmlns="urn:ndoc-schema">NOTE:</b> the <a target="_top" href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html#createNewFile()" xmlns="urn:ndoc-schema">javadocs for <code xmlns="" xmlns:ndoc="urn:ndoc-schema">File.createNewFile</code></a> contain a vague yet spooky warning about not using the API for file locking. This warning was added due to <a target="_top" href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4676183" xmlns="urn:ndoc-schema">this bug</a>, and in fact the only known problem with using this API for locking is that the Lucene write lock may not be released when the JVM exits abnormally.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>When this happens, a <a href="Lucene.Net.Store.LockObtainFailedException.html">LockObtainFailedException</a> is hit when trying to create a writer, in which case you need to explicitly clear the lock file first. You can either manually remove the file, or use the <a href="Lucene.Net.Index.IndexWriter.Unlock.html">Unlock</a> API. But, first be certain that no writer is in fact writing to the index otherwise you can easily corrupt your index.<p xmlns="urn:ndoc-schema"></p><p xmlns="urn:ndoc-schema"></p>If you suspect that this or any other LockFactory is not working properly in your environment, you can easily test it by using <a href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>, <a href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.<p xmlns="urn:ndoc-schema"></p></td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.SingleInstanceLockFactory.html">SingleInstanceLockFactory</a></td><td width="50%"> Implements <a href="Lucene.Net.Store.LockFactory.html">LockFactory</a> for a single in-process instance, meaning all locking will take place through this one instance. Only use this <b xmlns:ndoc="urn:ndoc-schema">LockFactory</b> when you are certain all IndexReaders and IndexWriters for a given index are running against a single shared in-process Directory instance. This is currently the default locking for RAMDirectory. </td></tr><tr valign="top"><td width="50%"><a href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a></td><td width="50%"> A <a href="Lucene.Net.Store.LockFactory.html">LockFactory</a> that wraps another <b xmlns:ndoc="urn:ndoc-schema">LockFactory</b> and verifies that each lock obtain/release is "correct" (never results in two processes holding the lock at the same time). It does this by contacting an external server (<a href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a>) to assert that at most one process holds the lock at a time. To use this, you should also run <b xmlns:ndoc="urn:ndoc-schema">LockVerifyServer</b> on the host &amp; port matching what you pass to the constructor. </td></tr></table></div></div></body></html>